# Dependency Injection (Внедрение зависимостей)

### Суть механизма
**Dependency Injection (DI)**
  Это паттерн проектирования, который делает объекты в приложении *слабо связанными* (Loose Coupling). Объекты взаимодействуют не напрямую с конкретными классами, а через *абстракции* (интерфейсы).

**Главная цель**
  Сделать систему *гибкой*, *адаптируемой* и *расширяемой*. Если один объект зависит от другого, мы не создаем его вручную (через `new`), а "получаем" извне.


### Основные понятия
**Зависимость (Dependency)**
  Это любой объект, который используется внутри другого объекта для выполнения работы.
  В контексте ASP.NET Core такие зависимости принято называть *Сервисами*.

**Абстракция**
  В C# для реализации DI обычно используются *Интерфейсы*.
  Зависимый объект знает только о методах интерфейса, но не знает, какой именно класс (реализация) выполняет работу.

### Inversion of Control (IoC)
**IoC (Инверсия управления)**
  Это общий принцип (архитектурный стиль), при котором "контроль" над выполнением программы передается от вашего кода к фреймворку.
  *DI — это частный случай (способ реализации) принципа IoC.*

**IoC Container (DI Container)**
  Это специальная "фабрика" или механизм, который управляет созданием зависимостей и их внедрением.
  Вместо того чтобы программист писал `new Service()`, контейнер сам находит нужную реализацию и подставляет её в класс.

### Реализация в ASP.NET Core
**Встроенный DI-контейнер**
  ASP.NET Core содержит встроенную фабрику, которая реализует интерфейс `IServiceProvider`.
  Вам не нужно искать сторонние библиотеки (как Autofac или Ninject) для базовых задач — всё работает "из коробки".

**Задачи контейнера**
  *Регистрация:* Сопоставление абстракций (Интерфейсов) с конкретными типами (Классами).
  *Резолвинг (Resolution):* Создание экземпляров объектов и автоматическое внедрение в них всех необходимых вложенных зависимостей.
  *Управление временем жизни:* Контейнер решает, когда создать объект, а когда уничтожить его (освободить память).

### Преимущества (Зачем это нужно)
**Упрощение поддержки**
  Если нужно заменить базу данных или логику отправки почты, мы меняем реализацию в *одном месте* (при регистрации в контейнере), а не бегаем по всему проекту, меняя `new OldService()` на `new NewService()`.

**Тестируемость**
  Благодаря интерфейсам, в тестах можно легко подменить реальный сервис (например, отправку денег) на "фейковый" (mock), чтобы проверить логику без риска.

**Управление жизненным циклом**
  Мы можем настроить, как часто создается сервис:
  * *Transient:* Новый экземпляр каждый раз.
  * *Scoped:* Один экземпляр на один HTTP-запрос.
  * *Singleton:* Один экземпляр на всё время работы приложения.