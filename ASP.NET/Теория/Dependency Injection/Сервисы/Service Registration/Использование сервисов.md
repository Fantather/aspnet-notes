### Подготовка (Классы сервисов)
В примерах ниже используется один интерфейс и две его реализации.
Этот код общий для всех сценариев
```c#
interface ITimeService
{
    string GetTime();
}

class ShortTimeService : ITimeService
{
    public string GetTime() => DateTime.Now.ToShortTimeString();
}

class LongTimeService : ITimeService
{
    public string GetTime() => DateTime.Now.ToLongTimeString();
}
```

### Варианты регистрации (Program.cs)
**Прямая регистрация класса** Мы привязываем конкретный класс. При запросе `LongTimeService` вернется экземпляр этого класса

_Минус:_ Сильная связность, так как мы зависим от конкретного типа, а не от интерфейса
```C#
var builder = WebApplication.CreateBuilder(args);
// Регистрация
builder.Services.AddTransient<LongTimeService>(); 
var app = builder.Build();
```


**Регистрация через Интерфейс (Стандарт)** Мы говорим контейнеру: "Если кто-то попросит `ITimeService`, дай ему `ShortTimeService`". Это обеспечивает слабую связность. Мы можем легко поменять реализацию на `LongTimeService` в одной строчке.
```C#
builder.Services.AddTransient<ITimeService, ShortTimeService>();
```


**Регистрация через метод расширения (Библиотечный подход)** Используется для группировки регистрации сервисов, чтобы не захламлять `Program.cs`. Часто применяется в сторонних библиотеках.
```C#
// В Program.cs
builder.Services.AddTimeService();

// В отдельном файле
public static class ServiceProviderExtensions
{
    public static void AddTimeService(this IServiceCollection services)
    {
        services.AddTransient<ITimeService, ShortTimeService>();
    }
}
```


### Варианты получения сервисов (Consumption)
**Service Locator (Получение вручную)**
Использование `app.Services` или `context.RequestServices`

_Важно:_ Внутри обработки запроса (например, в `MapGet` или `Run`) лучше использовать `context.RequestServices`, чтобы корректно работали _Scoped_ сервисы.
```C#
app.Run(async context =>
{
    // Получаем реализацию, которая была привязана к ITimeService
    var timeService = context.RequestServices.GetService<ITimeService>();
    
    // Проверка на null обязательна, если сервис не найден
    await context.Response.WriteAsync($"Time: {timeService?.GetTime()}");
});
```


**Внедрение в Middleware**
В Middleware сервисы часто внедряются в метод `InvokeAsync`, а не в конструктор. Это позволяет использовать _Scoped_ и _Transient_ сервисы внутри Middleware, который сам по себе живет как _Singleton_.

```C#
class TimeMessageMiddleware
{
    private readonly RequestDelegate next;

    public TimeMessageMiddleware(RequestDelegate next)
    {
        this.next = next;
    }

    // Сервис внедряется сюда автоматически при каждом запросе
    public async Task InvokeAsync(HttpContext context, ITimeService timeService)
    {
        context.Response.ContentType = "text/html;charset=utf-8";
        await context.Response.WriteAsync($"<h1>Time: {timeService.GetTime()}</h1>");
    }
}

// Подключение middleware
app.UseMiddleware<TimeMessageMiddleware>();
```


### GetService vs GetRequiredService
При получении сервисов вручную (через Service Locator) существует два основных метода. Разница между ними заключается в поведении при отсутствии запрошенного сервиса в контейнере.

`GetService<T>`
  Возвращает `null`, если сервис не зарегистрирован.
  *Используй этот метод только тогда, когда зависимость является опциональной, и у тебя есть логика обработки ситуации, когда сервиса нет.*

`GetRequiredService<T>`
  Выбрасывает исключение `InvalidOperationException`, если сервис не зарегистрирован.
  *Это предпочтительный метод для 99% случаев. Он позволяет реализовать принцип Fail Fast: если обязательная зависимость отсутствует, приложение должно сообщить об этом немедленно, а не падать позже с непонятным `NullReferenceException` при попытке использования null-объекта.*

#### Пример поведения
```csharp
app.Run(async context =>
{
    // Сценарий: Мы забыли сделать builder.Services.AddTransient<ITimeService>();

    // 1. GetService (Тихая неудача)
    var service1 = context.RequestServices.GetService<ITimeService>();
    // service1 равен null. Ошибки нет, пока мы не попробуем вызвать метод:
    // service1.GetTime(); // <- Тут вылетит NullReferenceException

    // 2. GetRequiredService (Явная ошибка)
    // Требует: using Microsoft.Extensions.DependencyInjection;
    var service2 = context.RequestServices.GetRequiredService<ITimeService>();
    // Тут СРАЗУ вылетит InvalidOperationException: "No service for type 'ITimeService' has been registered."
    // Это гораздо понятнее для разработчика.
});
```