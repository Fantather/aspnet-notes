Встроенный механизм привязки модели в ASP.NET Core отлично справляется со стандартными задачами преобразования данных из HTTP-запроса в объекты C#. Однако в специфических сценариях требуется создание собственного привязчика, реализующего интерфейс `IModelBinder`


## Архитектура: папка Infrastructure
Подобные классы не являются ни контроллерами, ни моделями базы данных, ни бизнес-сервисами. Они расширяют базовое поведение фреймворка ASP.NET Core

**Инфраструктурный код**
  Классы пользовательских привязчиков, фильтров, провайдеров и атрибутов валидации принято размещать в отдельной папке на уровне проекта, которая обычно называется `Infrastructure`

**Изоляция логики**
  Вынесение таких классов в папку `Infrastructure` помогает отделить технические детали работы HTTP-конвейера от чистой бизнес-логики приложения


## Реализация собственного привязчика
Рассмотрим ситуацию, когда клиент передает дату и время отдельными полями (например, ключи `Date` и `Time` в строке запроса), а в контроллере мы хотим получить готовый объект `DateTime`


### 1. Создание класса привязчика (IModelBinder)
Класс должен реализовать метод `BindModelAsync`, который использует `ValueProvider` для извлечения сырых данных и `ModelBindingResult` для возврата результата
```csharp
using Microsoft.AspNetCore.Mvc.ModelBinding;

namespace MyProject.Infrastructure
{
    public class CustomDateTimeModelBinder : IModelBinder
    {
        private readonly IModelBinder fallbackBinder;
        
        public CustomDateTimeModelBinder(IModelBinder fallbackBinder)
        {
            this.fallbackBinder = fallbackBinder;
        }

        public Task BindModelAsync(ModelBindingContext bindingContext)
        {
            // с помощью поставщика значений получаем данные из запроса
            var datePartValues = bindingContext.ValueProvider.GetValue("Date");
            var timePartValues = bindingContext.ValueProvider.GetValue("Time");

            // если не найдено значений с данными ключами, вызываем привязчик модели по умолчанию
            if (datePartValues == ValueProviderResult.None || timePartValues == ValueProviderResult.None)
                return fallbackBinder.BindModelAsync(bindingContext);

            // получаем значения
            string? date = datePartValues.FirstValue;
            string? time = timePartValues.FirstValue;

            // Парсим дату и время
            DateTime.TryParse(date, out var parsedDateValue);
            DateTime.TryParse(time, out var parsedTimeValue);

            // Объединяем полученные значения в один объект DateTime
            var result = new DateTime(
                parsedDateValue.Year,
                parsedDateValue.Month,
                parsedDateValue.Day,
                parsedTimeValue.Hour,
                parsedTimeValue.Minute,
                parsedTimeValue.Second);

            // устанавливаем результат привязки
            bindingContext.Result = ModelBindingResult.Success(result);
            return Task.CompletedTask;
        }
    }
}
````


### 2. Создание провайдера привязчика (IModelBinderProvider)
Фреймворк не создает экземпляры привязчиков напрямую. Для этого используется фабрика — провайдер, реализующий `IModelBinderProvider`. Провайдер решает, _для какого типа данных_ следует применять наш привязчик

```C#
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.AspNetCore.Mvc.ModelBinding.Binders;

namespace MyProject.Infrastructure
{
    public class CustomDateTimeModelBinderProvider : IModelBinderProvider
    {
        public IModelBinder? GetBinder(ModelBinderProviderContext context)
        {
            // Проверяем, является ли целевой тип структурой DateTime
            if (context.Metadata.ModelType == typeof(DateTime))
            {
                // Для объекта SimpleTypeModelBinder необходим сервис ILoggerFactory
                // Получаем его из коллекции сервисов
                ILoggerFactory loggerFactory = context.Services.GetRequiredService<ILoggerFactory>();
                
                // Создаем наш привязчик, передавая ему стандартный в качестве fallback
                IModelBinder binder = new CustomDateTimeModelBinder(new SimpleTypeModelBinder(typeof(DateTime), loggerFactory));
                return binder;
            }
            
            return null;
        }
    }
}
```

### 3. Регистрация провайдера в Program.cs
Чтобы конвейер ASP.NET Core узнал о новом провайдере, его необходимо добавить в глобальную коллекцию параметров MVC при настройке сервисов в `Program.cs`

```C#
// Добавление нашего собственного провайдера в начало коллекции (индекс 0)
builder.Services.AddControllersWithViews(opts =>
{
    opts.ModelBinderProviders.Insert(0, new CustomDateTimeModelBinderProvider());
});
```