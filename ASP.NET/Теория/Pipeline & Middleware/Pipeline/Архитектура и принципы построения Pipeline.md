## Принципы проектирования компонентов
При создании middleware следует придерживаться строгих архитектурных границ, чтобы избежать высокой связности (coupling) и обеспечить тестируемость.

**Принцип единственной ответственности (Single Responsibility Principle)**
  Каждый middleware должен выполнять строго одну задачу. *Не объединяй логирование, аутентификацию и валидацию в одном компоненте; это нарушает модульность и усложняет отладку.*

**Отсутствие состояния в Middleware (Stateless Middleware)**
  Сам объект middleware (экземпляр класса) не должен хранить состояние, специфичное для конкретного HTTP-запроса, в своих полях. *Поскольку экземпляр middleware часто создается один раз на время жизни приложения (Singleton), сохранение данных запроса в полях приведет к состоянию гонки (race condition) при параллельных запросах.* Данные запроса должны храниться исключительно в `Context`

**Явные зависимости**
  Если middleware зависит от результатов работы предыдущего компонента, эта зависимость должна реализовываться через стандартизированные контракты в `Context` (например, ClaimsPrincipal для пользователя), а не через жесткие привязки к реализации другого middleware.


## Стратегия упорядочивания (Middleware Ordering)
Порядок регистрации компонентов в конвейере определяет не только последовательность выполнения логики, но и область действия (scope) защиты и обработки ошибок.

### Рекомендуемая структура слоев
**1. Глобальная обработка исключений (Exception Handling)**
  Должна быть зарегистрирована первой (в самом начале). *Находясь на вершине стека вызовов, этот слой способен перехватить исключения из любой точки конвейера, разматывающегося внутри него, и преобразовать их в корректный HTTP-ответ.*

**2. Безопасность транспорта (HSTS, HTTPS Redirection)**
  Обеспечивает защищенный канал до начала какой-либо обработки данных.

**3. Статические файлы**
  Часто размещаются здесь, чтобы отдавать ресурсы без накладных расходов на аутентификацию (если файлы публичные).

**4. Аутентификация (Authentication)**
  Определяет, *кто* делает запрос. Должна отработать до того, как система попытается проверить права доступа.

**5. Авторизация (Authorization)**
  Определяет, *что* пользователю разрешено делать. Зависит от успешной аутентификации.

**6. Бизнес-логика / Маршрутизация (Routing & Endpoints)**
  Терминальная часть конвейера, где происходит сопоставление маршрута и выполнение целевого действия контроллера или хендлера.


## Управление зависимостями (Dependency Injection)
Архитектура pipeline в современных фреймворках (например, ASP.NET Core) разделяет время жизни самого компонента и используемых им сервисов.

**Constructor Injection (Внедрение в конструктор)**
  Используется для сервисов с жизненным циклом Singleton (живут все время работы приложения). *Здесь внедряются объекты, не зависящие от контекста запроса, например, логгеры или конфигурационные опции.*

**Method Injection (Внедрение в метод Invoke)**
  Используется для сервисов с жизненным циклом Scoped (живут в рамках одного запроса). *Поскольку метод `Invoke` вызывается для каждого запроса отдельно, сюда безопасно передавать репозитории данных или сервисы бизнес-логики, специфичные для текущей операции.*

[[Captive Dependency|Подробнее тут]]

## Распространенные антипаттерны
**Преждевременная терминация (Premature Short-circuiting)**
  Блокировка запроса (например, валидация) до того, как отработали middleware логирования или диагностики. *Это приводит к «слепым зонам» в мониторинге, когда отклоненные запросы не фиксируются системой.*

**Изменение ответа после начала отправки**
  Попытка модифицировать заголовки или статус-код ответа в фазе исходящего потока (после `next()`), если терминальный middleware уже начал запись в поток ответа (Body). *Архитектурно необходимо проверять состояние `Response.HasStarted` перед модификацией.*