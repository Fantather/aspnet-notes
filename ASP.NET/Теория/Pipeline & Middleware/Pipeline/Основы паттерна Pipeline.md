*Pipeline (Конвейер)* — это архитектурный стиль и паттерн проектирования, который организует процесс обработки запроса или данных как последовательность вызовов независимых обработчиков (компонентов).

Каждый компонент выполняет свою изолированную задачу и принимает решение: передать управление следующему компоненту в цепи или прервать выполнение и вернуть результат.


## Ключевые компоненты
**Контекст (Context)**
  Объект, инкапсулирующий состояние обрабатываемого запроса. *Он является общим для всех этапов конвейера и передается от одного обработчика к другому.* Контекст обычно содержит входящие данные, формируемый ответ и служебную информацию (метаданные).

**Middleware (Промежуточное ПО / Обработчик)**
  Функциональный блок, встроенный в конвейер. *Middleware не имеет жесткой связности с другими компонентами; он знает только о том, что существует некий «следующий» шаг.*

**Делегат запроса (Request Delegate / Next)**
  Ссылка на следующий компонент в цепочке. Вызов этого делегата инициирует передачу управления дальше по конвейеру.


## Механизм выполнения
Работа Pipeline характеризуется двунаправленным потоком управления, который реализуется через вложенность вызовов функций (рекурсию или стек вызовов).

**Фаза входящего потока (Upstream / Request)**
  Логика выполняется до вызова делегата `next()`. *Здесь происходит валидация входных данных, аутентификация, обогащение контекста информацией или начало транзакции.*

**Передача управления**
  Компонент вызывает `next()`, тем самым приостанавливая свое выполнение и передавая поток управления следующему middleware в списке.

**Терминальная операция**
  Момент, когда один из компонентов решает не вызывать `next()` или когда цепочка заканчивается. *Здесь формируется базовый ответ, и процесс разворачивается в обратную сторону.*

**Фаза исходящего потока (Downstream / Response)**
  Логика выполняется после возврата управления из `next()`. *Стек вызовов раскручивается, позволяя компонентам модифицировать ответ, замерить время выполнения всего вложенного участка цепи или закрыть ресурсы.*

## Управление потоком (Control Flow)
**Стандартная цепь**
  Каждый компонент выполняет свою работу и вызывает следующий. Запрос проходит через всю систему от первого до последнего элемента и обратно.

**Short-circuiting (Короткое замыкание)**
  Намеренное прерывание конвейера. Если middleware обнаруживает, что дальнейшая обработка невозможна или не требуется (например, запрос некорректен или ответ найден в кэше), оно не вызывает `next()`. *В этом случае управление немедленно возвращается предыдущему компоненту, а все последующие middleware в цепи игнорируются.*

## Пример логической структуры
Ниже приведен псевдокод, демонстрирующий вложенность вызовов, характерную для pipeline.

```csharp
// Имитация абстрактного Middleware
public class Middleware
{
    private Middleware _next;

    public void Invoke(Context context)
    {
        // 1. Логика входящего запроса (Request phase)
        PreProcess(context);

        // 2. Передача управления
        if (_next != null)
        {
            _next.Invoke(context);
        }
        else
        {
            // Терминальная операция (если нет следующего)
            HandleTerminal(context);
        }

        // 3. Логика исходящего ответа (Response phase)
        PostProcess(context);
    }
}
```