## Методы регистрации компонентов
Построение конвейера происходит в методе конфигурации при старте приложения. Порядок написания кода (сверху вниз) строго соответствует порядку вызова middleware при входящем запросе.

**Метод Use (Chaining / Цепочка)**
  Основной метод для встраивания компонента. Принимает контекст запроса и делегат `next`. *Компонент, добавленный через `Use`, обязан вызвать `next()`, чтобы передать управление дальше, либо намеренно не вызывать его, чтобы прервать цепь (short-circuit).*

**Метод Run (Terminal / Терминал)**
  Регистрирует компонент как финальную точку обработки. *Синтаксис метода `Run` обычно не предоставляет доступ к делегату `next`, что делает невозможным передачу управления дальше. После выполнения этого блока конвейер начинает раскручиваться обратно.*

**Метод Map (Branching / Ветвление)**
  Создает ответвление от основного конвейера на основе пути запроса. *Если критерий ветвления (например, URL начинается с `/api`) выполняется, управление переходит в изолированную ветку, которая имеет свой собственный набор middleware и свой терминальный элемент.*

## Определение терминального Middleware
Ключевой принцип: **Ответ (Response Body) формирует только один middleware**. Остальные компоненты лишь модифицируют заголовки или управляют побочными эффектами.

### Как понять, что компонент должен быть терминальным?
Компонент должен быть последним в цепи (использовать `Run`), если его задача подпадает под одну из категорий:

**Генерация контента**
  Компонент создает полезную нагрузку (JSON, HTML, файл), которую ждет клиент. *Технически невозможно корректно записать данные в поток ответа (Stream) из двух разных мест одновременно без коррапции данных.*

**Маршрутизация к бизнес-логике**
  Эндпоинт (Endpoint), который выполняет целевое действие (например, сохранение заказа в БД), является терминальным по определению. *После выполнения бизнес-задачи запрос считается обработанным.*

**Обработка статики**
  Если компонент нашел и отдал файл с диска, работа сервера завершена.

### Роль нетерминальных компонентов (Wrappers)
Все компоненты, стоящие *до* терминального, выполняют роль оберток.

**До вызова next()**
  Они подготавливают почву: проверяют права, читают куки, открывают транзакции. *Они не пишут в тело ответа, так как еще не знают, будет ли запрос успешным.*

**После вызова next()**
  Они получают управление, когда терминальный компонент уже отработал и сформировал ответ. *Здесь они могут только замерить время, залогировать результат или глобально обработать ошибку, возникшую внутри.*

## Пример синтаксиса (C# / ASP.NET Core)
Ниже приведен пример кода, иллюстрирующий разницу между транзитным (`Use`) и терминальным (`Run`) синтаксисом.

```csharp
public void Configure(IApplicationBuilder app)
{
    // 1. Транзитный middleware (Use)
    // Его задача — служебная (логирование), он не формирует ответ.
    // Поэтому он ОБЯЗАН вызвать next.Invoke().
    app.Use(async (context, next) =>
    {
        Console.WriteLine("Log: Запрос пришел"); // Logic Before
        
        await next.Invoke(); // Передача управления дальше
        
        Console.WriteLine("Log: Ответ ушел");   // Logic After
    });

    // 2. Ветвление (Map)
    // Если путь /status, уходим в отдельную ветку.
    app.Map("/status", statusApp => 
    {
        // В этой ветке свой терминальный middleware
        statusApp.Run(async context => 
        {
            await context.Response.WriteAsync("Workings");
        });
    });

    // 3. Терминальный middleware (Run)
    // Если код дошел сюда (не ушел в Map), то это конец цепи.
    // next здесь отсутствует. Мы формируем итоговый ответ.
    app.Run(async context =>
    {
        await context.Response.WriteAsync("Page Not Found or Default Response");
    });
}