Атрибутная маршрутизация (Attribute Routing) — это механизм, при котором маршруты определяются непосредственно в контроллерах и методах действий с помощью C# атрибутов.

Для активации этого механизма в `Program.cs` используется метод:
```csharp
app.MapControllers();
````

### Принцип работы
При запуске приложения метод `MapControllers`:
1. Сканирует сборку на наличие публичных классов, наследующих `ControllerBase` (или `Controller`)

2. Ищет над ними и их методами атрибуты маршрутизации (`[Route]`, `[HttpGet]` и др.)

3. Регистрирует найденные маршруты в таблице эндпоинтов.

В отличие от конвенциональной маршрутизации, здесь нет единого шаблона. 
URL каждого метода формируется индивидуально путем объединения *маршрута контроллера* и *маршрута метода*

### Ключевые атрибуты
**[Route("template")]**
Задает базовый шаблон маршрута. Может применяться как к классу контроллера, так и к методу.

Если применен к классу, он становится префиксом для всех методов внутри.


**HTTP-глаголы ([HttpGet], [HttpPost], [HttpPut], [HttpDelete])**
Ограничивают метод обработки конкретным HTTP-методом.

Могут принимать шаблон маршрута в качестве аргумента, объединяя функцию `[Route]` и ограничение метода (например, `[HttpGet("{id}")]`).


**[ApiController]**
Специальный атрибут для REST API контроллеров.

Хотя он не является маршрутом сам по себе, он включает строгие проверки требований к атрибутной маршрутизации (например, требует наличие атрибута маршрута у контроллера).


### Токены замены (Token Replacement)
Для удобства и соблюдения принципа DRY (Don't Repeat Yourself) используются токены в квадратных скобках. Они автоматически подставляют имена классов и методов.

**[controller]**
Заменяется на имя класса контроллера без суффикса "Controller".

_Пример:_ Для `ProductsController` токен `[controller]` превратится в `products`.

**[action]**
Заменяется на имя метода действия.

_Редко используется в REST API_, так как URL должен указывать на ресурс (существительное), а не на действие.


### Формирование пути
Итоговый путь складывается по формуле: `Префикс контроллера` + `/` + `Шаблон метода`.

Если метод помечен атрибутом маршрута, начинающимся со слэша `/` (например, `[Route("/global/path")]`), то префикс контроллера игнорируется, и маршрут считается абсолютным.

### Пример реализации

C#

```
using Microsoft.AspNetCore.Mvc;

namespace MyApi.Controllers;

// Базовый маршрут для всех методов в классе: "api/users"
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    // 1. GET api/users
    // Шаблон метода пуст, используется только шаблон контроллера
    [HttpGet]
    public IActionResult GetAll()
    {
        return Ok(new[] { "User1", "User2" });
    }

    // 2. GET api/users/{id}
    // Шаблон метода добавляет параметр id
    // Ограничение типа: id должен быть int
    [HttpGet("{id:int}")]
    public IActionResult GetById(int id)
    {
        return Ok($"User {id}");
    }

    // 3. POST api/users
    // Обработка POST-запроса по базовому адресу
    [HttpPost]
    public IActionResult Create([FromBody] object user)
    {
        return Created("api/users/1", user);
    }

    // 4. GET api/users/active
    // Статический сегмент "active" добавляется к базовому пути
    [HttpGet("active")]
    public IActionResult GetActiveUsers()
    {
        return Ok("Active users list");
    }
    
    // 5. Игнорирование префикса контроллера
    // Абсолютный путь, доступен по: GET /search
    [HttpGet("/search")]
    public IActionResult GlobalSearch()
    {
        return Ok("Global Search");
    }
}
```

### Особенности использования

- _Явность:_ Глядя на код метода, сразу понятно, по какому URL он доступен.
    
- _REST-стандарт:_ Позволяет легко создавать ресурсы с иерархией (например, `orders/5/items`).
    
- _Гибкость:_ Разные методы одного контроллера могут иметь совершенно разные структуры URL, если это необходимо.
    

```

Теперь можем переходить к следующему файлу. Написать **Conventional Routing (MapControllerRoute)**?
```