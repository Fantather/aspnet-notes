Конвенциональная маршрутизация (Conventional Routing) — это подход, при котором маршруты к контроллерам определяются глобально в `Program.cs` с помощью строковых шаблонов.

Вместо настройки каждого метода отдельно, приложение использует *соглашения* (conventions), чтобы сопоставить входящий URL с соответствующим классом и методом.

Для активации используется метод:
```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
````

### Структура шаблона
Шаблон маршрута состоит из сегментов, заключенных в фигурные скобки (токены).


**{controller}**
Определяет имя класса контроллера.
Система берет значение из URL и добавляет к нему суффикс `Controller` для поиска класса (например, сегмент `catalog` ищет класс `CatalogController`).


**{action}**
Определяет имя публичного метода внутри найденного контроллера.
Сегмент `index` будет искать метод `public IActionResult Index()`.


**{id}**
Определяет параметр маршрута.
Значение этого сегмента будет передано в аргумент метода с тем же именем (чувствительно к регистру при привязке моделей).


### Синтаксис настройки параметров
**Значения по умолчанию (Default Values)**
Используется знак `=`. Если сегмент отсутствует в URL, подставляется указанное значение.
_Пример:_ `{controller=Home}` означает, что при запросе корня сайта `/` будет вызван `HomeController`.


**Необязательные параметры (Optional Parameters)**
Используется знак `?`. Если сегмент отсутствует, маршрут все равно считается совпавшим, а аргумент метода получает `null` (или значение по умолчанию типа).
_Пример:_ `{id?}` позволяет вызывать метод как `/details/5`, так и `/details`.


**Параметры-ловушки (Catch-all)**
Используется знак `*` или `**`. Захватывает оставшуюся часть URL, включая слэши.
_Пример:_ `{**slug}` захватит `blog/2023/january/post-1`.


### Приоритет и множественные маршруты
В приложение можно добавить несколько вызовов `MapControllerRoute`. Поиск совпадений происходит **сверху вниз** в порядке регистрации.

Если URL подходит под первый шаблон, остальные игнорируются. Поэтому более специфичные маршруты должны регистрироваться раньше общих.

```C#
// 1. Специфичный маршрут для админки
// URL /admin/users вызовет AdminController.Users()
app.MapControllerRoute(
    name: "admin",
    pattern: "admin/{action=Index}/{id?}",
    defaults: new { controller = "Admin" });

// 2. Общий маршрут (Default)
// Ловит всё остальное
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```


### Примеры сопоставления
Шаблон: `"{controller=Home}/{action=Index}/{id?}"`
**URL: `/`**
Controller: `Home` (по умолчанию)
Action: `Index` (по умолчанию)
Id: `null`

**URL: `/Products`**
Controller: `Products`
Action: `Index` (по умолчанию)
Id: `null`

**URL: `/Products/Details/5`**
Controller: `Products`
Action: `Details`
Id: `5`


### Особенности использования
**Преимущества**
Централизованное управление. Весь стиль URL определен в одном месте.
Удобно для UI-приложений (MVC), где структура URL часто предсказуема (`/Сущность/Действие/ID`).

**Недостатки**
Сложно поддерживать точные имена URL при рефакторинге (переименование метода контроллера меняет URL).
Менее очевидно для REST API, где URL должен отражать иерархию ресурсов, а не имена методов C#.

**Смешанный режим**
Можно использовать `MapControllerRoute` и `MapControllers` одновременно. Если контроллер помечен атрибутом `[Route]`, он перестает подчиняться конвенциональной маршрутизации и использует только атрибутную.