В подходе Minimal API маршруты регистрируются через специализированные методы расширения, соответствующие HTTP-глаголам. Это позволяет определять эндпоинты лаконично, без создания классов контроллеров.

### Основные методы регистрации
**MapGet**
  Регистрирует эндпоинт для обработки GET-запросов.
  _Используется для:_ Получения данных без их изменения.

**MapPost**
  Регистрирует эндпоинт для обработки POST-запросов.
  _Используется для:_ Создания новых ресурсов или отправки данных на обработку.

**MapPut**
  Регистрирует эндпоинт для обработки PUT-запросов.
  _Используется для:_ Полного обновления существующего ресурса (замена).

**MapDelete**
  Регистрирует эндпоинт для обработки DELETE-запросов.
  _Используется для:_ Удаления ресурсов.

**MapPatch**
  Регистрирует эндпоинт для обработки PATCH-запросов.
  _Используется для:_ Частичного обновления ресурса.


### Структура регистрации
Метод принимает два обязательных аргумента:
1. **Шаблон маршрута (`string pattern`)**: Путь URL, по которому будет доступен эндпоинт.
2. **Обработчик (`Delegate handler`)**: Функция (обычно лямбда-выражение), которая выполняется при совпадении маршрута.

```csharp
app.MapGet("/route", handler);
````


### Привязка параметров (Parameter Binding)
В Minimal API параметры обработчика заполняются автоматически из различных источников запроса. Порядок поиска значений зависит от типа параметра.

**Параметры маршрута (Route Values)**
Извлекаются из сегментов URL, указанных в фигурных скобках.
_Пример:_ `app.MapGet("/users/{id}", (int id) => ...)`

**Строка запроса (Query String)**
Извлекается из параметров после знака `?` в URL.
_Пример:_ Запрос `/search?q=apple` автоматически замапится в параметр `(string q)`.

**Тело запроса (Body)**
Если параметр является сложным объектом (классом/рекордом), система пытается десериализовать тело запроса (JSON) в этот объект.
_Примечание:_ Работает по умолчанию для `MapPost` и `MapPut`.

**Внедрение зависимостей (Services)**
Если тип параметра зарегистрирован в DI-контейнере, он будет передан в метод.
_Пример:_ `(IConfiguration config)` будет взят из сервисов, а не из URL.


### Возвращаемые значения
Обработчик может возвращать различные типы данных, которые ASP.NET Core автоматически конвертирует в HTTP-ответ.

**Строка (string)**
Возвращается как `text/plain`.

**Объект (Object / Record)**
Сериализуется в JSON с кодом 200 OK.

**IResult**
Интерфейс для управления статусом ответа, заголовками и телом.
Для создания используются статические классы `Results` или `TypedResults`.
_Примеры:_ `Results.Ok(data)`, `Results.NotFound()`, `Results.Created("/uri", obj)`

**Task / ValueTask**
Используется для асинхронной обработки (`async/await`).


### Примеры реализации
```C#
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// 1. Простой GET
app.MapGet("/hello", () => "Hello World");

// 2. Использование параметров маршрута
app.MapGet("/users/{id}", (int id) => $"User ID: {id}");

// 3. POST с получением данных из тела (JSON)
// Класс User автоматически десериализуется
app.MapPost("/users", (User user) => 
{
    // Логика сохранения...
    return Results.Created($"/users/{user.Id}", user);
});

// 4. Внедрение сервисов и асинхронность
app.MapGet("/weather", async (IWeatherService service) => 
{
    var forecast = await service.GetForecastAsync();
    return Results.Ok(forecast);
});

app.Run();

// DTO для примера
record User(int Id, string Name);
```