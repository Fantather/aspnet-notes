Механизм ASP.NET Core, отвечающий за сопоставление входящего HTTP-запроса с исполняемым кодом (эндпоинтом).

В отличие от старых версий ASP.NET, где маршрутизация была частью MVC, в Core используется глобальная система **Endpoint Routing**, доступная для всего приложения (gRPC, SignalR, Controllers, Razor Pages).


### Основные этапы
Маршрутизация разделена на два дискретных шага, реализуемых разными Middleware:

* **Сопоставление (Route Matching)**
  Выполняется в `UseRouting`. На этом этапе система анализирует URL и находит подходящий `Endpoint`.
  *Результат:* Найденный эндпоинт сохраняется в `HttpContext` (функция `GetEndpoint()`), но **код обработчика еще не запускается**.
  Это позволяет другим Middleware (например, Аутентификации) увидеть, какой эндпоинт *будет* выполнен, и проверить права доступа до фактического запуска логики.

* **Выполнение (Route Dispatching)**
  Выполняется в `UseEndpoints`. Этот компонент берет эндпоинт, сохраненный на предыдущем этапе, и запускает его делегат.


### Ключевые термины
* **Endpoint (Эндпоинт)**
  Конечная точка обработки запроса. Содержит делегат (код, который нужно выполнить) и коллекцию метаданных (атрибуты авторизации, фильтры и т.д.).

* **Route Template (Шаблон маршрута)**
  Строка, описывающая структуру URL. Может содержать литералы (статический текст) и параметры (переменные части).
  *Пример:* `products/{category}/{id?}`

* **Route Values (Значения маршрута)**
  Словарь значений, извлеченных из URL на основе шаблона.
  Если шаблон `users/{id}`, а запрос `/users/42`, то в Route Values будет `id = 42`.


### Синтаксис шаблонов
* **Литералы**
  Точное совпадение текста.
  `api/reports`

* **Параметры**
  Значения в фигурных скобках.
  `users/{id}`

* **Ограничения (Constraints)**
  Уточнение типа данных параметра.
  `users/{id:int}` (сработает только если id — число)

* **Необязательные параметры**
  Знак вопроса в конце.
  `search/{query?}`


### Особенности Minimal Hosting (.NET 6+)
В современных приложениях (`WebApplication`) явный вызов Middleware маршрутизации часто опускается.

**Неявная регистрация**
  Если методы `UseRouting` и `UseEndpoints` отсутствуют в коде, фреймворк добавляет их автоматически:
  1. `UseRouting` добавляется в начало конвейера.
  2. Выполнение эндпоинтов происходит в конце `app.Run()`.

**Регистрация маршрутов**
  Объект `app` сам выступает строителем маршрутов.
  Вместо вложенности в `UseEndpoints`, методы вызываются прямо на приложении: `app.MapGet(...)`, `app.MapControllers()`.


### Пример конфигурации (Явный vs Неявный)
**Современный подход** (Implicit)
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Маршрутизация происходит неявно здесь (в начале)

app.UseAuthentication();
app.UseAuthorization();

// Регистрация эндпоинтов прямо на app
app.MapControllers();
app.MapGet("/hello", () => "Hello World");

// Выполнение эндпоинтов происходит неявно здесь
app.Run();
````

**Классический подход** (Explicit)
  Используется, когда нужен строгий контроль порядка вызова Middleware.
```C#
app.UseRouting(); // 1. Нашли эндпоинт

app.UseCors();    // Политики могут зависеть от эндпоинта
app.UseAuthorization();

app.UseEndpoints(endpoints => // 2. Выполнили эндпоинт
{
    endpoints.MapControllers();
});
```


**Почему разделение важно?**
  Если бы маршрутизация и выполнение были одним шагом, Middleware авторизации (`UseAuthorization`) не мог бы узнать, требует ли целевой метод атрибут `[Authorize]`, пока этот метод не начал бы выполняться. Разделение позволяет проверить права доступа _на основе метаданных эндпоинта_ до того, как будет вызван хоть одна строчка бизнес-логики