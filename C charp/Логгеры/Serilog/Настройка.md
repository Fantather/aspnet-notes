После скачивания пакетов, мы настраиваем логгер
Это должно происходить в Main, до любого другого кода, что бы логгер был готов к работе раньше, чем любая другая часть приложения

У Serilog конфигурация потоковая, мы пишем `LoggerConfiguration()`, а дальше добавляем настройки через точку

На пример, мы напишем `Log.Information("Приложение завершило работу")`, а Serilog запишет: `[INFO] Приложение завершило работу`

Порядок не имеет значения



#### Уровни логгирования
`.MinimumLevel` - Это фильтр, через него мы указываем минимальный уровень сообщений, с которыми будет работать Логгер

- *Verbose*
  Используется для пошагового логгирования кода (Трассировки потока выполнения)
  Нужен только для отладки очень сложных, глубоких проблем, когда нужно знать точный порядок вызовов
  
  Примеры:
  - `Log.Verbose("Вошли в метод CalculateTotal()");`
  - `Log.Verbose("Переменная 'sum' = {Sum}", sum);`
  - `Log.Verbose("Выходим из метода CalculateTotal()");`


- *Debug*
  Используется для логгирования промежуточных этапов выполнения
  Нужен записи результата какой-то операции, который полезен во время отладки, но не нужен во время обычной работы
  
  Примеры:
  - `Log.Debug("Данные пользователя {UserId} успешно загружены из базы.", userId);`
  - `Log.Debug("Кэш очищен. Удалено {Count} элементов.", cache.Count);`


- *Information*
  Используется для логгирования Нормальной работы приложения, сюда записываются события, которые мы ожидаем увидеть
  Благодаря этому мы можем узнать, на каком этапе работы приложения возникла проблема
  
  Примеры:
  - `Log.Information("Приложение запущено.");` (Мы это уже сделали в `Program.cs`!)
  - `Log.Information("Пользователь {UserId} вошел в систему.", user.Id);`
  - `Log.Information("Отчет {ReportName} успешно сгенерирован.", report.Name);`
  - `Log.Information("Подключение к сервису X... успешно.");`
  - `Log.Information("Заказ {OrderId} оформлен.", order.Id);`


- *Warning*
  Используется для логгирования Неожиданных ситуаций, которые не помешали завершению операции и не почти не повлияли на пользователя
  
  Примеры:
  - `Log.Warning("Файл конфигурации 'settings.xml' не найден. Используются настройки по умолчанию.");`
   Приложение работает, но не так, как мог ожидать пользователь
   
  - `Log.Warning("Запрос к API занял {Duration} мс. (Превышен порог в 2000 мс)", elapsedMs);`
   Все работает, но медленно, стоит обратить внимание


- *Error*  
  Используется для логгирования Исключений, которые были отловлены в try catch, но прервали выполнение операции
  
  Примеры:
  - `Log.Error(ex, "Не удалось сохранить файл для пользователя {UserId}", userId);`
   Мы обязательно передаем сюда сам `ex` (Exception), Serilog красиво его запишет со всем стеком вызовов
   
  - `Log.Error("Ошибка валидации при регистрации. Email: {Email}", email);`
   Операция "Регистрация" не удалась


- *Fatal*
  Используется для логгирования Исключения, которое не было отловлено в try catch и вот вот уронит приложение


#### Sinks
`.WriteTo` - указываем, куда направить лог, точек назначения может быть несколько

Приёмники:
 - *.Console()*
   Пишет логи в окно консоли (или в "Вывод" / "Output" в Visual Studio)
   Идеально для отладки во время разработки
- *.File()* - Записывает логи в файл
- *.Seq()* - супер-полезный графический интерфейс для логов
- *.Elasticsearch()*
- *.Sentry()*
- *.MSSqlServer()* - записывает логи прямо в базу данных
- и много чего ещё


#### Enrich
`.Enrich` - добавляют данные в сообщения логов, дают добавить больше контекста
Например, мы напишем `Log.Error("Ошибка")`, а Serilog запишет: `[2025-11-08 21:40] [ERR] [Поток: 1] [Компьютер: DEV-PC] Ошибка`

*.WithThreadId()* - Добавляет номер потока, в котором было написано сообщение (Для работы нужен NuGet пакет Serilog.Enrichers.Thread)
*.WithMachineName()* - Добавляет имя компьютера (Для работы нужен NuGet пакет Serilog.Enrichers.Environment)
*.WithProperty(...)* - Добавляет наше собственное, статическое свойство к логам, принимает две строки, одна из них ключ, вторая значение

На пример с такой записью `.Enrich.WithProperty("ApplicationName", "MainApp")` получится
`[INFO] (App: MainApp) Приложение запущено.`

```C#
.Enrich.WithThreadId() // 1. ID Потока
.Enrich.WithMachineName() // 2. Имя компьютера
.Enrich.WithProperty("ApplicationName", "MyCoolApp") // 3. Свой ключ и свойство под ним
```

#### LogContext.PushProperty
Используется для того что бы временно добавить в вывод какое-то свойство
Пока вызовы логгера будут находиться внутри `using` *PushProperty*, логгер будет содержать дополнительное свойство

Пример
```C#
public void ProcessOrder(int orderId)
{
    // "Наклеиваем" ярлык OrderId только на время выполнения этого метода
    using (LogContext.PushProperty("OrderId", orderId))
    {
        Log.Information("Начинаем обработку заказа."); 
        // -> Этот лог будет содержать {OrderId: 123}
        
        // ... какая-то работа ...
        
        Log.Warning("Заказ требует ручной проверки.");
        // -> Этот лог тоже будет содержать {OrderId: 123}
    }
    
    Log.Information("Обработка завершена.");
    // -> А этот лог УЖЕ НЕ БУДЕТ содержать {OrderId: 123}
}
```