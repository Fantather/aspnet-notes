*Join*
- Соединяет две последовательности по общему ключу
- Создает плоский список пар элементов, у которых совпали ключи


**Выполнение**
`DE-B` - первым делом считывает весь источник данных в память (буферизует его), применяет к этой полной коллекции свою логику (сортирует, группирует) и только после этого начинает возвращать элементы из уже готового результата


**Сигнатура**

- `outer` - Внешняя последовательность
- `inner` - Внутренняя последовательность
  
- `outerKeySelector` - Как получить ключ из элемента
  внешней последовательности
- `innerKeySelector` - Как получить ключ из элемента внутренней последовательности
  
- `resultSelector` - Как сформировать результат

```C#
public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(
    this IEnumerable<TOuter> outer,
    IEnumerable<TInner> inner,
    Func<TOuter, TKey> outerKeySelector,
    Func<TInner, TKey> innerKeySelector,
    Func<TOuter, IEnumerable<TInner>, TResult> resultSelector
)
```


**Как это работает**
Метод принимает
- Две последовательности `outer` и `inner`
- Методы, которые вычисляют ключи у `outer` и `inner` последовательностей
- Для каждого элемента из `outer` находится один Соответствующий элемент из `inner` с совпадающим ключом
- К каждой найденной паре применяется `resultSelector`
- Возвращается плоский список объектов `TResult`


**Особенности**
`Join` - не группирует значения, то есть - если функция выбора ключа совпадёт несколько раз для одного и того-же значения, то будет создано несколько объектов с одинаковым ключом


 **Примеры**
Получаем пары значений `Имя-Сумма заказа` у тех экземпляров классов `Customers` и `Orders` в которых поле `Id` и `Customerid` - равны

Если заказа нет - покупатель не попадёт в этот анонимный тип
```C#
customers.Join (orders,
c => c.Id
o => o.CustomerId,
(c, o) => new {c.Name, o.Total}
);
```