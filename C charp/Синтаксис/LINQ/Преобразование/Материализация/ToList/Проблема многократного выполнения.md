Многие LINQ-запросы используют **отложенное выполнение (deferred execution)**, что означает:
- Запрос не выполняется до момента фактического перечисления результатов
- При каждом перечислении запрос выполняется заново
- Для "дорогих" операций это может быть проблемой


### Когда это особенно важно:
1. **Запросы к базе данных**: Чтобы не делать multiple round-trips к БД
2. **Сетевые запросы**: Чтобы избежать multiple HTTP-запросов
3. "Дорогие" вычисления: Чтобы не повторять вычисления
4. **Когда данные могут меняться**: Чтобы работать с согласованным набором данных

### Дополнительные преимущества:
- **Согласованность данных**: Гарантия, что все части кода работают с одинаковыми данными
- **Потокобезопасность**: Локальная копия безопасна для чтения из multiple threads
- **Производительность**: Последующие операции выполняются быстрее


### Пример проблемы
```C#
// Функция, которая долго выполняется
int ExpensiveOperation(int x)
{
    Thread.Sleep(100); // Имитация долгой операции
    return x * 2;
}

// Создаем запрос
var numbers = Enumerable.Range(1, 5);
var query = numbers.Select(ExpensiveOperation);

// МНОГОКРАТНОЕ ВЫПОЛНЕНИЕ:
var first = query.First(); // Выполняются все операции (5 раз)
var count = query.Count(); // Выполняются все операции СНОВА (5 раз)
var sum = query.Sum();     // Выполняются все операции ЕЩЕ РАЗ (5 раз)

// Итого: 15 вызовов ExpensiveOperation вместо 5
```

### Решение через материализацию
```C#
// Материализуем запрос ОДИН РАЗ
var materialized = query.ToList(); // 5 вызовов ExpensiveOperation

// Дальнейшие операции работают с готовой коллекцией
var first = materialized.First(); // Мгновенно
var count = materialized.Count(); // Мгновенно  
var sum = materialized.Sum();     // Мгновенно

// Итого: только 5 вызовов ExpensiveOperation
```