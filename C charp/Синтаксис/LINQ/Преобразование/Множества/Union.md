Объединяет две последовательности и возвращает не повторяющиеся элементы из каждой коллекции, удаляя дубликаты (логическое ИЛИ для множеств)

Требует перегрузки `GetHashCode`, а так же `Equals` или передачи собственного компаратора

Сложность - `O(n + m)`

**Выполнение**
`DE-B` - Буферизующее выполнение
Использует `HashSet` под капотом для обеспечения уникальности, поэтому порядок элементов не гарантируется

**Перегрузки**
- `arr1.Union(arr2)` - По умолчанию используется стандартный компаратор `EqualityComparer<T>.Default`
- `arr1.Union(arr2, comparer)` - Поддерживает пользовательский компаратор


**Пример**
```C#
var list1 = new List<int> { 1, 2, 3 };
var list2 = new List<int> { 3, 4, 5 };
var result = list1.Union(list2); // { 1, 2, 3, 4, 5 } (порядок может измениться)
```

С пользовательским компаратором (для case-insensitive сравнения строк)
```C#
var names1 = new[] { "John", "jane" };
var names2 = new[] { "JOHN", "bob" };
var uniqueNames = names1.Union(names2, StringComparer.OrdinalIgnoreCase);
// { "John", "jane", "bob" } - "JOHN" считается дубликатом "John"
```