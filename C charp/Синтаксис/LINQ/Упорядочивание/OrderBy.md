`OrederBy` - Первичная сортировка
Упорядочивает коллекцию по какому-то ключу и задаёт основной порядок сортировки

`OrederByDescending` - тоже самое, но по убыванию

Это `Стабильная сортировка` - если у двух элементов одинаковый ключ, их порядок относительно исходной коллекции сохранится


**Выполнение**
`DE-B` - первым делом считывает весь источник данных в память (буферизует его), применяет к этой полной коллекции свою логику (сортирует, группирует) и только после этого начинает возвращать элементы из уже готового результата

**Внутренняя оптимизация**
* **Работа со ссылками**: При сортировке метод **не создает копии** самих объектов. Вместо этого он строит внутреннюю карту (массив индексов), указывающую на оригинальные элементы в памяти. Сортируются только эти легкие ссылки, что значительно экономит память и ускоряет процесс
* **Конвейер (Pipeline)**: Специальная оптимизация работает именно для методов **`Skip`**, **`Take`** и **`ElementAt`**.
  Благодаря внутренней карте индексов, эти методы позволяют "перепрыгнуть" ненужные элементы или взять диапазон, не обращаясь к самим объектам в памяти. Остальные методы (например, `Where`) будут обрабатывать элементы потоково, но без возможности "перескочить" проверку.

**Характер выполнения: Отложенное, но Жадное (Deferred & Greedy)**
1. **Отложенное (Deferred):** Сама строка `query.OrderBy(...)` ничего не делает. Выполнение не начинается, пока не будет вызван метод перебора (`ToArray`, `ToList`, `foreach`).
2. **Жадное (Greedy):** Как только перебор запущен, `OrderBy` обязан сразу считать всю коллекцию в память (буферизовать), чтобы выстроить индексы. Он не может отдать даже первый элемент, не просмотрев всю коллекцию до конца (вдруг последний элемент должен быть первым?).

**Пример**
Упорядочивание по свойству `City`
```C#
people.OrderBy(p => p.City);
```