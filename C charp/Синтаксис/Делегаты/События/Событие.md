**Event** - это механизм уведомления, объект сообщает о каком-то событии, а другие объекты подписываются и их обработчики начинают выполнять код в ответ на это сообщение

**В коде** это особое свойство класса, помеченное ключевым словом `event`, которое инкапсулирует доступ к делегату:
- Извне на это поле можно только подписываться (`+=`) и отписываться (`-=`)
- `?.Invoke()` можно вызвать только из кода, которому доступен сам делегат (Владелец события или его наследники)
- Может быть любым делегатом, но принято давать ему тип `EventHandler`
 
Подписаться - добавить метод в список методов (`InvocationList`), которые вызовутся, когда событие сработает

**Технические детали**
- Это свойство хранит в себе приватное поле с делегатом
- `Event` автоматически создаёт методы `add` и `remove` (`+=` и `-=`)

**Назначение событий**
- Оповещения других объектов о каком-то событии
- Инкапсуляции - чтобы внешний код не мог вызвать делегат (`?.Invoke`), стереть все подписки или заменить весь список методов

**Уточнения**
- Технически может возвращать значения, но это не принято, потому что из Списка событий которые возвращают значения, будет возвращено значение только последнего метода в списке

- Если на событие никто не подписан, оно будет `null`
  Поэтому рекомендуется вызов через `MyEvent?.Invoke`

**Особенности написания кода**
- Метод поднимающий событие не принято делать доступным внешнему коду
- Для вызова события обычно прописывают отдельный `protected` метод и делают его `virtual`, что бы дочерние классы могли прописать свою логику
- Писать же методы которые позволяют внешнему коду свободно вызывать событие не принято и считается плохо практикой

**Особенности именования**
*Традиционный подход*
- Метод обработчик события начинается с `On`
- Название класса содержащего дополнительную информацию о событии заканчивается на `EventArgs`
- Обработчик принимает `Object` под названием `sender` и Наследника EventArgs под названием `e`

```C#
public class MyClass
{
    // Традиционные события
    // EventHandler и EventHandler<EventArgs> это одно и то же
    public event EventHandler? SomethingHappened;
    public event EventHandler<EventArgs>? SomethingAlsoHappened;

    // Событие не совсем по правилам, но допустимое
    public event EventHandler<string>? SomethingHappenedString;

    // Нетрадиционное событие с возвращаемым значением
    public event Func<int, int> NotTraditionalEvent;



    // InformationEventArgs - этот класс тут не прописан
    // Но допустим, это класс содержащий дополнительную информацию о событии
    // Метод который что-то делает и как побочный эффект вызывает События
    public void DoSomething()
    {
        // Без дополнительных параметров
        SomethingHappened?.Invoke(this, EventArgs.Empty);

        // С параметрами
        SomethingAlsoHappened?.Invoke(this, new InformationEventArgs(...));

        // Вызов и передача string напрямую, без EventArgs
        SomethingHappenedString?.Invoke(this, "Hi");
    }
}

public class AnotherClass
{
    public AnotherClass()
    {
	    // Допустим я создал объект MyClass
        MyClassObject.SomethingAlsoHappened += OnSomethingAlsoHappened;
        MyClassObject.SomethingHappenedString += OnSomethingHappenedString;
    }
    private void OnSomethingAlsoHappened(object sender, InformationEventArgs e)
    {
        Console.WriteLine(e.Message);
    }

    private void OnSomethingHappenedString(string e)
    {
        Console.WriteLine(e);
    }
}
```

`EventArgs` - Это пустой класс, он создан для абстракции, от него наследуются
`EventHandler` - Делегат создан для того, что бы не нужно было прописывать собственный при объявлении Событий и их Обработчиков