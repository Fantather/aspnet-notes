Интерфейс `IComparable` реализуется внутри класса и используется для сравнения одного и того же типа между собой
Определяет, как именно сравнивать Класс или структуру между собой

Используется, если нужен только один способ сравнения объектов, иначе, лучше использовать `IComparer`

Требования:
- Если `CompareTo(x, y) == 0`, то `x.Equals(y)` **должен** возвращать `true`, и `GetHashCode` у них должен быть одинаковым
  Поэтому, если ты определяешь в `CompareTo` сравнение по каким-то полям (например, по `Id` и `Name`), то в `Equals` и `GetHashCode` стоит включить **те же самые** поля.

- Коллекции .NET (например, `List<T>.Sort()`, `Array.BinarySearch` и т.д.) **полагаются** на то, что:
1. Если `x.CompareTo(y) < 0`, то `x` идёт **до** `y`
2. Если `x.CompareTo(y) == 0`, то они считаются равными: порядок между ними не важен
3. Если `x.CompareTo(y) > 0`, то `x` идёт **после** `y`
   
   Если твоя реализация нарушает эти правила (например, возвращает `0`, хотя на самом деле одно поле меньше, а другое — больше; либо не обеспечивает транзитивность: `a<b`, `b<c`, но вдруг `a>c`), то алгоритмы сортировки и поиска могут «зависать» или дать неверный результат.


Используется:
- В методах `Sort<T>` у `List<T>`
- В `LINQ` при сравнении объектов
- В алгоритмах поиска/сортировки
- В `SortedList`, `SortedDictionary`


Содержит метод `CompareTo(T other)`, он Возвращает значение типа `int`:
- `-1` или `< 0` - текущий объект меньше `other`
- `0` - объекты равны
- `1` или `> 0` - текущий объект больше `other`
```C#
public class Person : IComparable<Person>
{
	public string Name { get; set; }
    public int Age { get; set; }
    
    public int CompareTo(Person? other)
    {
	    if(other is null) return 1; // Любой объект больше null
	    return Age.CompareTo(other.Age)
    }
}
```

Использование
```C#
List<Person> people = new List<Person>;
people.Sort(); // Вызовет CompareTo
```