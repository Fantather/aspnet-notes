# Техничный вариант
### Снижение связанности (Loose Coupling) и инверсия зависимостей
Использование конкретных классов создает **жесткую связанность** (Tight Coupling). Это нарушает принцип открытости/закрытости (OCP) и усложняет рефакторинг.

* **Проблема:** Если класс `OrdersService` напрямую инстанцирует `PostgresManager`, он становится зависимым от конкретной реализации БД. Любое изменение в способе хранения данных потребует правки бизнес-логики сервиса.
* **Решение:** `OrdersService` должен зависеть от абстракции (интерфейса) `IDataRepository`, а не от детали реализации. Конкретный экземпляр внедряется через **Dependency Injection** (DI).
* **Результат:** Это позволяет подменять реализацию без изменения клиентского кода. Например, миграция с PostgreSQL на MongoDB или замена провайдера курсов валют (`PrivatBank` -> `Monobank`) сводится к регистрации новой реализации интерфейса в DI-контейнере.

### Изоляция в Unit-тестировании
Это критический аспект для обеспечения качества кода (Quality Assurance).

* **Суть:** Unit-тесты должны проверять логику изолированно, быстро и детерминировано. Прямая зависимость от внешних систем (БД, API, файловая система) делает тесты медленными и нестабильными (flaky tests).
* **Решение:** Интерфейсы позволяют использовать **Mock-объекты** (имитации). В тестовой среде вместо реального подключения к БД в сервис передается Mock-реализация `IDataRepository`, которая возвращает заранее определенные данные в памяти.
* **Результат:** Мы тестируем чистую бизнес-логику, исключая влияние сети или базы данных.

### Контрактное программирование и полиморфизм
Интерфейс определяет **контракт** взаимодействия — набор публичных методов и свойств, которые обязан реализовать класс.

* **Применение:** Это необходимо при разработке библиотек, плагинов или модульных систем. Вы определяете интерфейс (например, `IPlugin`), а внешние разработчики пишут свои реализации.
* **Результат:** Система может работать с любыми объектами, реализующими этот интерфейс, не зная их внутренней структуры (полиморфизм). Это гарантирует предсказуемое поведение внешних модулей.

---

### Принцип целесообразности (YAGNI / KISS)
Введение интерфейсов увеличивает когнитивную нагрузку и количество файлов в проекте. Не следует применять абстракции преждевременно ("Speculative Generality").

* **Критерий:** Если класс является простым DTO (Data Transfer Object), внутренней утилитой или его реализация гарантированно единственна и не требует изоляции для тестов — интерфейс избыточен.
* **Вывод:** Интерфейсы необходимы там, где требуется **подменяемость** (в runtime или compile-time), **тестируемость** (изоляция) или четкое **разделение слоев** архитектуры.


----
# Более понятный вариант
### Уменьшение зависимости (Гибкость кода)
Когда один класс жестко «знает» про другой конкретный класс, их трудно разделить. Это как приварить деталь намертво вместо того, чтобы прикрутить на болтах.

* **Проблема:** Если твой класс `OrdersService` внутри себя создает конкретный `PostgresManager`, он становится зависимым от него. Если ты захочешь поменять базу данных или просто логику сохранения, тебе придется переписывать код самого сервиса.
* **Решение:** Сервис не должен сам создавать менеджера БД. Он должен просто «просить» любой инструмент, который соответствует интерфейсу `IDataRepository`.
* **Результат:** Ты можешь легко менять «детали» (Postgres на MongoDB, реальный банк на тестовый), не ломая и не переписывая основной код программы.

### Упрощение тестирования (Unit-тесты)
Тесты должны быть быстрыми и надежными. Если код жестко привязан к реальной базе данных или API, тестировать его сложно.

* **Суть:** Когда ты проверяешь формулу скидки, тебе не нужно реально подключаться к серверу банка. Это долго, требует интернета, и банк может быть недоступен.
* **Решение:** Благодаря интерфейсу, в тесте ты можешь подсунуть сервису не реальный класс работы с банком, а «заглушку» (Mock). Эта заглушка не лезет в сеть, а мгновенно возвращает нужный тебе ответ (например, «Курс евро = 42»).
* **Результат:** Ты проверяешь только свою логику, не завися от внешнего мира. Без интерфейсов подменить реальный объект на заглушку было бы почти невозможно.

### Контракт и предсказуемость (Полиморфизм)
Интерфейс — это строгий договор (контракт). Он гарантирует, что у класса точно есть определенные методы.

* **Применение:** Представь, что у тебя есть список разных платежных систем: PayPal, Visa, Bitcoin. Все они работают по-разному внутри. Но если все они реализуют интерфейс `IPayment`, твоей программе всё равно, как они устроены.
* **Результат:** Ты можешь обращаться к ним одинаково: `payment.Process()`. Это и есть **полиморфизм** в действии — возможность работать с разными типами объектов через один общий интерфейс, не зная деталей их реализации.


## Целесообразность использования интерфейсов
Интерфейсы — это инструмент абстракции. Как и любой инструмент, они усложняют структуру кода ради гибкости. Использовать их нужно только тогда, когда выгода от гибкости превышает сложность поддержки.

### Когда интерфейсы НЕОБХОДИМЫ

Использование оправдано, если выполняется хотя бы одно из условий:

1.  **Множественность реализаций (Полиморфизм)**
    Ситуация, когда одно и то же действие должно выполняться по-разному в зависимости от контекста.
    * **Пример:** Система уведомлений. У тебя есть сервис рассылки, и ты хочешь отправлять сообщения в Telegram, на Email и по SMS.
    * **Решение:** Создаешь интерфейс `IMessageSender` с методом `Send()`. Реализуешь три класса: `TelegramSender`, `EmailSender`, `SmsSender`.
    * **Выгода:** Основной код программы не знает, *как* отправляется сообщение. Он просто берет список всех `IMessageSender` и вызывает у каждого `Send()`. Добавить новый способ (например, Push-уведомление) можно, не меняя старый код.

2.  **Изоляция внешних зависимостей (Тестирование)**
    Ситуация, когда код зависит от медленных, платных или нестабильных внешних систем (API банка, жесткий диск, время, случайные числа).
    * **Пример:** Процессинг оплаты. Тебе нужно протестировать логику корзины покупок, но ты не можешь каждый раз при запуске тестов списывать деньги с реальной карты.
    * **Решение:** Код зависит от `IPaymentGateway`.
    * **Выгода:** В тестах ты подставляешь "фейковую" реализацию (`MockPaymentGateway`), которая всегда говорит "Оплата прошла успешно". Ты тестируешь свою логику, а не работу банка.

3.  **Инверсия зависимостей (Архитектура)**
    Ситуация, когда высокоуровневая бизнес-логика не должна зависеть от низкоуровневых деталей (БД, драйверов).
    * **Принцип:** "Бизнес-правила не должны меняться, если мы решили сменить базу данных".

---

### Когда интерфейсы ИЗЛИШНИ (Over-engineering)

Ошибка новичков — создавать интерфейс для каждого класса (паттерн "Header Interface"). Это засоряет проект и усложняет навигацию.

Не создавай интерфейс, если:

**У класса есть и будет только одна реализация**
Если это специфический внутренний хелпер (например, `RegexStringParser`), который решает узкую задачу и никогда не будет заменен на что-то другое — интерфейс ему не нужен.

**Это класс-модель (DTO / Entity)**
Классы, которые просто хранят данные (например, `User`, `OrderDto`, `Config`), никогда не должны прятаться за интерфейсами. У них нет сложного поведения, которое нужно подменять.

**Ты не планируешь писать Unit-тесты для этого участка**
Если код тривиален или пишется "на один раз" (скрипт, прототип), интерфейсы только замедлят разработку.

### Итог
* Если ты можешь ответить на вопрос "Какую вторую реализацию этого класса я могу представить?", и ответ реалистичен — **нужен интерфейс**.
* Если ты хочешь покрыть код, использующий этот класс, Unit-тестами — **нужен интерфейс**.
* В остальных случаях — **используй конкретный класс**