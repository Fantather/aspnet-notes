*Интерфейс* - это контракт, который описывает то что обязаны реализовать Класс или Структура, которые наследуют этот интерфейс (с *С# 8.0* появилась возможность задавать реализацию по умолчанию, поэтому я решил не упоминать, что в интерфейсе не должно быть реализации, ибо это уже не так)

Интерфейсы могут наследоваться друг от друга, расширяя функционал родительского интерфейса

Класс может наследовать несколько интерфейсов

По умолчанию все члены интерфейса `public`, с C# 8.0 могут быть 

**Содержимое интерфейса**
Интерфейс может содержать сигнатуры
- Методов
- Свойств
- Событий 
- Индексаторов
- `static` или `const` поля со значением по умолчанию (C# 8.0+)

В интерфейсе нельзя иметь
- Экземплярные поля (нет памяти для хранения данных)
- Конструкторы (интерфейс нельзя создавать напрямую)


**Цели использования интерфейсов**
- *Полиморфизм*
  Это главнейшая цель. Код может работать с интерфейсом, а не с конкретными классами
  Это позволяет обрабатывать разнородные объекты единообразно, если они реализуют один и тот же интерфейс
  
- *Создание слабосвязанной архитектуры*
  Компоненты системы зависят от абстракций (интерфейсов), а не от конкретных реализаций
  Это делает код более гибким и удобным для тестирования и модификации
  
- *Множественное наследование*
  В C# класс может наследоваться только от одного другого класса, но может реализовывать *сколько угодно* интерфейсов
  Это обходной путь для множественного наследования поведения (но не состояния)

**Interface Segregation Principle - ISP**
Один из принципов *SOLID*
Он гласит, что лучше иметь много специфичных интерфейсов, чем один универсальный. Клиенты не должны зависеть от методов, которые они не используют. Интерфейсы позволяют создавать точно targeted контракты


Объявление интерфейса
```C#
public interface IMyInterface
{
    void MyMethod(); // Метод без реализации
    int MyProperty { get; set; } // Свойство без реализации
    event EventHandler MyEvent; // Событие без реализации
}
```