Коротко: **`record`** — это тип в C#, который по умолчанию ведёт себя как **значение**, а не как **идентичность**: у него автоматически генерируются _value-equality_ (`Equals`, `GetHashCode`), удобный `ToString()`, деструктурирование и поддержка **`with`**-копирования.

Ниже — ровно то, что важно на практике.

# Что даёт `record`

- **Value-equality**: два `record` равны, если равны их содержательные поля/свойства.
    
- **Иммутабельность “по умолчанию”** (если используешь позиционную форму или `init`): свойства обычно делаются `init`, и объект не меняется после создания.
    
- **`with`-копирование** (недеструктивная мутация): создаёт копию с изменёнными полями.
    
- Красивый **`ToString()`** и **деconstruction**.
    

# Варианты records

1. **Record-класс (ссылочный тип)** — стандартный вариант:
    

```csharp
public record Poem(string Title, string Author); // позиционная форма
// Эквивалентно:
public record Poem
{
    public string Title { get; init; }
    public string Author { get; init; }
}
```

Использование:

```csharp
var p1 = new Poem("Море", "Пушкин");
var p2 = new Poem("Море", "Пушкин");
bool eq = p1 == p2;            // true — сравнение по значению
var p3 = p1 with { Title = "К морю" }; // копия с изменением поля
```

2. **`record struct` (значимый тип)** — без выделения в куче, тоже с value-equality. Часто делают **`readonly record struct`** для полной неизменяемости:
    

```csharp
public readonly record struct Point(int X, int Y);
```

# Важные нюансы

- **Record ≠ автоматически “замороженный” объект.**  
    Иммутабельность — это следствие **`init`**-сетторов или отсутствия сеттеров. Если ты напишешь `set;`, объект станет изменяемым:
    
    ```csharp
    public record Poem { public string Title { get; set; } } // можно менять после создания
    ```
    
- **`with`** работает, когда свойства можно задать через инициализатор (обычно `init`):
    
    ```csharp
    var p2 = p1 with { Title = "Новое" }; // создаёт новую копию
    ```
    
- **Наследование**: у `record` своя модель. Наследоваться имеет смысл **между record-типами** (обычные классы и records не смешивают иерархии).
    
- **Производительность**:
    
    - `record class` — ссылочный тип (heap, GC).
        
    - `record struct` — значимый тип (копируется целиком; для больших объектов лучше `readonly`).
        

# Когда выбирать что

- **Нужны неизменяемые “данные” с равенством по содержимому** → `record` (часто позиционный, с `init`).
    
- **Нужна изменяемая сущность с идентичностью (жизненный цикл, поведение)** → обычный `class`.
    
- **Нужен компактный value-тип без аллокаций** → `record struct` / `readonly record struct`.
    

# Мини-шпаргалка

- Только читать коллекцию и элементы тоже неизменяемые → `record` + `init`-свойства.
    
- Только читать коллекцию, но элементы можно менять → `class` с `set;`-свойствами (и помни, что `IReadOnlyList<T>` не блокирует изменения самих элементов).
    

Хочешь проверить себя быстренько: в твоём `PoemCollection` — **стихи должны быть неизменяемы после создания** (титул/автор/год не меняются), или ты планируешь редактировать их свойства позже? (Один короткий ответ.)