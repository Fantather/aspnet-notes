**Общие принципы**
- Объекты, которые считаются **равными** (по `Equals`), должны возвращать **одинаковый хэш-код**. И наоборот — разные объекты _могут_ возвращать одинаковый код 
    
- Обычно используется алгоритм с начальным простым числом (например, 17) и умножением на другое простое число (например, 23) с добавлением `GetHashCode()` 
    
- Современный и удобный способ — `HashCode.Combine(...)` из .NET, автоматически объединяющий хэш-коды всех указанных полей


Более простой вариант
```C#
public override int GetHashCode()
{
	int hash = Rows ^ Cols;
	foreach(var item in data)
		hash ^= item.GetHashCode();
	
	return hash;
}
```


Вариант с более равномерным распределением ключей
```C#
public override int GetHashCode()
{
	unchecked
	{
		int hash = 17;
		hash = hash * 23 + Rows;
		hash = hash * 23 + Cols;
		
		foreach(var item in data)
			hash = hash * 23 + item.GetHashCode();
		
		return hash;
	}
}
```

- `unchecked` - Отключает проверку переполнения целочисленных операций в данном блоке, при выходе за пределы `int` результат просто обрежется по модулю 2³², не вызывая исключений

Литералы могут быть другими, но обычно это небольшие нечётные простые числа, потому что простые числа уменьшают число коллизий, но вы можете выбрать любые другие не‑ноль числа (ещё лучше — нечётные или простые). Главное, чтобы они были фиксированы и стабильно «размазывали» биты хэша. Например, часто встречаются пары `(17, 31)` или `(37, 59)`


Так же можно просто вызывать уже готовый Хэш-код
```C#

```