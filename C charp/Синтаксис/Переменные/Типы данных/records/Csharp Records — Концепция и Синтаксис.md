## Основная концепция
**Определение**
  *Record* (запись) — это ссылочный тип данных (reference type), введенный в C# 9, который обеспечивает семантику значения (value semantics) для сравнения. Он предназначен в первую очередь для хранения данных, а не для реализации поведения.

**Ключевая особенность**
  Два экземпляра `record` считаются равными, если равны значения их свойств, даже если это разные объекты в памяти. Обычные классы (`class`) сравниваются по ссылке (адресу в памяти).


## Синтаксис объявления
**Позиционная запись (Positional Record)**
  Самый краткий способ объявления. Компилятор автоматически создает свойства `init-only` и конструктор.

```csharp
// "Person" — это имя записи
// В скобках — параметры, которые станут свойствами
public record Person(string FirstName, string LastName, int Age);
````


**Явное объявление**
Можно объявлять свойства вручную, если нужна кастомная логика или мутабельность (хотя это не рекомендуется).

```C#
public record User
{
    public string Name { get; init; } = default!;
    public int Age { get; set; } // Можно делать изменяемым, но теряется смысл иммутабельности
}
```


## Особенности конструкторов
**Первичный конструктор (Primary Constructor)**
В позиционных записях параметры конструктора (`record User(string Name)`) автоматически становятся публичными свойствами. Это меняет подход к созданию объектов: вместо написания множества перегрузок конструкторов (Overloading), используется один главный конструктор и инициализаторы.

**Инициализация дополнительных свойств**
Если свойство не должно быть в конструкторе (например, `Id`, который генерируется автоматически), его выносят в тело записи. При создании объекта его можно задать через **Object Initializer**.

**Важно**
Запись приведённая ниже позволяет сделать параметр Id не обязательным, но при этом из-за init, в конструктор всё ещё можно передать id

```C#
public record User(string Name, int Age)
{
    // Свойство вне конструктора (имеет значение по умолчанию)
    public Guid Id { get; init; } = Guid.NewGuid();
}

// Использование:
// 1. Вызов первичного конструктора (обязательные поля)
// 2. Инициализатор (опциональные поля)
var user = new User("Alice", 25) 
{ 
    Id = existingGuid 
};
```


**Отличие от Class**
- **Class**: Требует явного написания свойств и присваивания им значений внутри конструктора (`this.Name = name`).
- **Record**: Компилятор сам генерирует свойства (`public string Name { get; init; }`) и код присваивания на основе параметров конструктора.


**Конструктор по умолчанию (Parameterless Constructor)**
По умолчанию, если объявлен первичный конструктор `record User(string Name)`, компилятор **не создает** пустой конструктор `User()`.

_Зачем нужен:_ В редких случаях (например, для **Lazy Loading** в EF Core или старых сериализаторов) библиотекам требуется создать пустой объект перед заполнением свойств.

_Как реализовать:_ Если такой конструктор необходим, его нужно объявить вручную. **Важное правило:** любой дополнительный конструктор в record обязан вызывать первичный конструктор через `this`.

```C#
public record User(string Name, int Age)
{
    // Приватный конструктор. 
    // Используем default!, чтобы "успокоить" компилятор. 
    // Реальные данные позже запишет EF Core/Сериализатор через рефлексию.
    private User() : this(default!, default!) { }
}
```


## Атрибуты в позиционных записях
**Проблема неоднозначности**
  В позиционной записи `record User(string Name)` параметры в скобках являются одновременно и *параметрами конструктора*, и *автосвойствами*. Если мы просто напишем атрибут `[JsonPropertyName]`, компилятор может не понять, к чему именно мы хотим его применить (к параметру или к свойству).

**Синтаксис Target Typing**
  Чтобы явно указать, что атрибут относится к *свойству* (property), используется ключевое слово `property:` внутри квадратных скобок.
```csharp
using System.Text.Json.Serialization;

public record class Movie(
    // Указываем: этот атрибут для СВОЙСТВА, а не параметра
    [property: JsonPropertyName("poster_path")] string PosterPath,
    
    [property: JsonPropertyName("vote_average")] float VoteAverage,
    
    // Если имена совпадают, атрибут не нужен
    string Title 
);
```

**Где это используется**
  Чаще всего применяется при десериализации JSON (превращении текста в объект), когда имена полей в базе данных (snake_case) отличаются от принятых в C# (PascalCase).