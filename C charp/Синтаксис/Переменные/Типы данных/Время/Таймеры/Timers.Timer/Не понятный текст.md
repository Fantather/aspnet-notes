 - В отличие от `System.Windows.Forms.Timer`/`DispatcherTimer`, `System.Timers.Timer` не гарантирует вызов обработчика в UI-потоке — события приходят в потоках пула потоков (но есть свойство `SynchronizingObject`, которое позволяет маршалить события на UI-поток в WinForms при необходимости).

- **Важно:** `System.Threading.Timer` тоже выполняет свои обратные вызовы в потоках пула потоков и может вызываться на разных потоках пула потоков. `System.Timers.Timer` дополнительно предоставляет событие `Elapsed` и удобства (например, `ElapsedEventArgs`, свойство `SynchronizingObject`, `AutoReset` и т.д.), а также проще интегрируется со средой событий .NET.

Оба работают с ThreadPool по умолчанию, но `System.Timers.Timer` — более «событийно-ориентированный» (имеет `Elapsed`), и может быть настроен для маршалинга на конкретный синхронизируемый объект



**Не понятные замечания**
- Обработчик выполняется в потоке пула потоков (если `SynchronizingObject` не задан), значит внутри обработчика нельзя напрямую обращаться к UI-элементам без маршалинга.
- Обработчик может выполняться параллельно (reentrancy): если выполнение обработчика занимает дольше интервала и `AutoReset == true`, второе срабатывание может начаться на другом потоке. См. раздел про синхронизацию и предотвращение reentrancy.


**О многопоточности и синхронизации**
- Поскольку обработчики выполняются в потоках пула потоков, используйте `lock`, `Interlocked`, `SemaphoreSlim` или другие механизмы синхронизации при доступе к общим данным.

- Если обработчик может выполняться параллельно и это нежелательно - либо:
    - Останавливайте таймер в начале обработчика и включайте в конце; либо
    - Используйте флаг `Interlocked.Exchange` для одноразового входа; либо
    - Установите `AutoReset = false` и вручную `Start()` в конце обработчика

- Для UI-приложений:
    - В WinForms можно задать `timer.SynchronizingObject = someControl;` — тогда событие `Elapsed` будет маршалиться на поток создателя `someControl` (обычно UI-поток).
    - В WPF чаще используют `DispatcherTimer` для работы в основном потоке UI.