*Garbage Collector* - это компонент среды выполнения (На пример, [[CLR]] в .NET), механизм автоматического управления памятью
Его основная задача - освобождать память, занятую объектами, которые больше не используются приложением

**Проблема которую он решает**
В языках без GC (например, C/C++) разработчик сам отвечает за выделение и освобождение памяти через `malloc`/`new` и `free`/`delete`

Это часто приводит к ошибкам:
- *Утечки памяти*
  Если забыть освободить память, то она останется занятой, хотя программа её уже не использует
  Со временем это может привести к тому что
   - система будет работать медленнее
   - программа может упасть из-за нехватки памяти
   - ресурсы компьютера будут расходоваться не эффективно

- *Висячие указатели*
  Обращение к памяти, которая уже была освобождена
  
- *Двойное освобождение*: повторная попытка освободить одну и ту же память

GC избавляет программиста от этих забот, делая процесс разработки более безопасным и продуктивным


**Достижимость**
GC в .NET использует концепцию *достижимых объектов* (reachable objects)
Основная идея:
- *Корни (GC Roots)* - Это начальные точки, от которых GC начинает анализ
  К ним относятся:
    - Глобальные и статические переменные
    - Локальные переменные и параметры методов в текущем стеке вызовов всех потоков
    - Указатели на объекты в регистрах CPU
    - Ссылки на объекты из [[Финализатор|финализируемой очереди]]

- *Достижимый объект*
  Объект считается достижимым, если на него прямо или косвенно ссылается какой-либо корень.
- *Недостижимый объект*
  Объект, до которого невозможно добраться ни из одного корня. Такой объект считается мусором и может быть удален.


**Принципы работы**
GC в первую очередь собирает мусор в Gen 0, так как это происходит чаще всего и требует наименьших затрат (память Gen 0 мала, и там скапливается больше всего мусора)
Сборка Gen 2 - это дорогостоящая операция, поэтому она происходит реже

1. *Поколение 0 (Gen 0)*
   Сюда помещаются самые молодые объекты
   Размер Gen 0 обычно небольшой (несколько МБ)
   Большинство объектов умирает молодыми (например, временные переменные в методе)

2. *Поколение 1 (Gen 1)*
   Это буферная зона между Gen 0 и Gen 2
   Объекты, которые пережили одну сборку мусора в Gen 0, перемещаются в Gen 1
   Размер Gen 1 также ограничен

3. *Поколение 2 (Gen 2)*
   Сюда попадают долгоживущие объекты (например, объекты, представляющие главную форму приложения или кэши данных)
   Объекты, пережившие сборку в Gen 1, перемещаются в Gen 2
   Размер Gen 2 может быть очень большим и ограничивается только доступной памятью процесса

4. *Large Object Heap* (LOH — Куча больших объектов)
   Отдельный регион для очень больших объектов (≥ 85 КБ в .NET Framework 4.5+)
   Такие объекты сразу попадают в LOH и считаются частью Gen 2
   Это сделано для того, чтобы избежать дорогостоящего копирования больших блоков памяти между поколениями