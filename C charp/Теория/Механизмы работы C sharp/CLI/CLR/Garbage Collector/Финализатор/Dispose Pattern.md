Из-за всех своих [[Недостатки финализатора|недостатков]] финализаторы **не должны** быть основным способом освобождения ресурсов
Для этого существует паттерн `IDisposable`

**Идея:**
1. Вы даете пользователю вашего класса публичный метод `Dispose()` (из интерфейса `IDisposable`), который он может (и должен) вызвать **явно и сразу**, как закончит работать с ресурсом.
   
2. Финализатор выступает в роли страховки
   Если программист забыл вызвать `Dispose()`, то финализатор вызовется когда-то потом и подберет за ним мусор

Этот паттерн известен как **Dispose Pattern** и выглядит так:
```C#
public class MyResourceHolder : IDisposable
{
    private bool _disposed = false; // Флаг для отслеживания состояния

    // Неуправляемый ресурс (условно)
    private IntPtr _unmanagedHandle;

    // Управляемый ресурс
    private FileStream _managedFileStream;

    // Публичный метод для явного освобождения ресурсов
    public void Dispose()
    {
        Dispose(true); // Вызываем полную очистку
        GC.SuppressFinalize(this); // УБИРАЕМ объект из очереди финализации!
        // Теперь GC может удалить объект сразу, не вызывая финализатор.
    }

    // Защищенный виртуальный метод, в котором происходит реальная работа
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            // Освобождаем УПРАВЛЯЕМЫЕ ресурсы (вызывая их Dispose)
            _managedFileStream?.Dispose();
        }

        // Освобождаем НЕУПРАВЛЯЕМЫЕ ресурсы
        CloseHandle(_unmanagedHandle); // Пример вызова нативной функции
        _unmanagedHandle = IntPtr.Zero;

        _disposed = true;
    }

    // ФИНАЛИЗАТОР (страховочная сетка)
    ~MyResourceHolder()
    {
        Dispose(false); // Вызываем очистку только неуправляемых ресурсов
    }

    // Пример использования
    public void DoSomeWork()
    {
        if (_disposed) throw new ObjectDisposedException("Object was disposed");
        // ... работа с ресурсами ...
    }
}

// Использование с помощью 'using' (рекомендуется)
using (var resource = new MyResourceHolder())
{
    resource.DoSomeWork();
} // Dispose() будет вызван автоматически здесь
```

**Ключевые моменты паттерна:**
- `Dispose(true)` вызывается из публичного `Dispose()` и освобождает и управляемые, и неуправляемые ресурсы
  
- `Dispose(false)` вызывается из финализатора
  Управляемые ресурсы (`FileStream`) в этот момент уже могут быть собраны GC, поэтому трогать их нельзя!!
  Мы освобождаем только неуправляемые ресурсы
  
- `GC.SuppressFinalize(this)`
  Критически важный вызов
  Он сообщает GC, что финализация больше не нужна, так как ресурсы уже освобождены вручную. Это позволяет объекту быть удаленным сразу