Процесс не ограничивается просто вызовом Деструктора (на пример, `~MyResourceHolder()`)
Он включает несколько этапов и две специальные *Очереди*

**Шаг 1: Помещение в очередь финализации**  
Когда вы создаете объект, у которого есть финализатор, .NET добавляет указатель на этот объект в специальную структуру данных, называемую *очередь финализации (finalization queue)*

**Шаг 2: Обнаружение мусора и перемещение**
1. В какой-то момент работает [[GC]]
2. Он обнаруживает, что объект `MyResourceHolder` больше недостижим (т.е. стал мусором)
3. [[GC]] проверяет, есть ли у этого объекта финализатор (записан ли он в очередь финализации)
4. Если финализатор есть, [[GC]] НЕ удаляет объект сразу
   Вместо этого он перемещает указатель на этот объект из _очереди финализации_ в другую структуру - *очередь "готовых к финализации" (freachable queue)*


**Шаг 3: Фоновая финализация**
- В CLR существует специальный поток с высоким приоритетом, предназначенный исключительно для финализации - *поток финализатора (finalizer thread)*

- Этот поток постоянно мониторит *freachable queue*
  Если в этой очереди есть объекты, поток извлекает их оттуда и поочередно вызывает их методы `Finalize()`


**Шаг 4: Финальное удаление**
- После того как финализатор объекта был выполнен, указатель на этот объект удаляется из *freachable queue*
  
  И только на *Следующей сборке мусора* (когда GC снова наткнется на этот уже обработанный объект), он увидит, что финализатор уже был вызван, и окончательно удалит объект из памяти