*Finalizer* - это специальный метод класса, который вызывается сборщиком мусора ([[GC]]) перед тем, как объект этого класса будет окончательно уничтожен и его память будет освобождена

Из-за всех своих [[Недостатки финализатора|недостатков]] финализаторы **не должны** быть основным способом освобождения ресурсов
Это крайняя мера для освобождения неуправляемых ресурсов, если разработчик забыл это сделать явно

**Особенности**
- Вызов финализатора недетерминирован и дорог для производительности
- Избегайте финализаторов, если только вы не работаете с неуправляемыми ресурсами напрямую
- Всегда реализуйте паттерн `IDisposable`, если ваш класс владеет ресурсами, которые нужно освобождать
- Используйте `using` или явный вызов `Dispose()` для своевременного освобождения ресурсов


**Метод** `Finalize()`
Определение Деструктора (`~ClassName()`) в C# это синтаксический сахар
На самом деле у сборщика мусора ([[GC]]) нет понятия деструктора
Вместо этого платформа использует концепцию *финализации*

Мы переопределяем метод `Finalize()`, базового класса `Object`, но мы не можем переопределить этот метод напрямую, вместо этого мы используем специальный синтаксис с `~`, будто прописываем Деструктор в С/С++

Подробнее:
Когда компилятор C# видит "деструктор", он выполняет следующую трансформацию:
1. Он создает переопределение `protected` метода `Finalize()`, который уже существует у базового класса `Object`
2. Код вашего "деструктора" помещается внутрь блока `try`
3. Вызов `base.Finalize()` помещается в блок `finally`

На пример этот код
```C#
public class MyResourceHolder
{
    // Финализатор
    // Здесь код для освобождения неуправляемых ресурсов
    ~MyResourceHolder()
    {
        Console.WriteLine("Финализатор был вызван!");
    }
}
```

Будет скомпилирован в
```C#
protected override void Finalize()
{
    try
    {
        // Ваш код финализатора
        Console.WriteLine("Финализатор был вызван!");
    }
    finally
    {
	    // Вызов финализатора базового класса
        base.Finalize();
    }
}
```