*Just In Time компилятор* - преобразует IL-код в машинные команды, при первом вызове метода, во время выполнения программы и сохраняет этот машинный код в оперативную память

После этого метод работает напрямую в машинном коде без повторной компиляции


**Механизм работы ленивой компиляции**
Перед исполнением метода Main среда CLR находит все типы данных, на которые ссылается программный код метода Main

Среда CLR берёт Тип данных и выделяет для него единственную внутреннюю структуру
Эта внутренняя структура данных содержит по одной записи для каждого метода, определённого во взятом Типе и каждая запись содержит адрес, по которому можно найти реализацию метода, я буду называть это Таблицей

Но при инициализации мы имеем IL-код, который ЦП не понимает
Так что в эти записи Таблицы заносится адрес внутренней недокументированной функции (JIT-компилятора), содержащейся в самой среде CLR

Когда Main впервые обращается методу какого-либо типа, то вызывается JIT-компилятор, который
- Ищет в метаданных сборки вызываемый тип и его метод
- Извлекает из метаданных IL-код метода
- Выделяет блок памяти
- Компилирует IL-код в машинный код, который сохраняется в выделенном блоке памяти
- Перезаписывает адрес хранящийся Записи таблицы на адрес выделенного блока памяти
- Передаёт управление машинному коду, содержащемуся в выделенном блоке памяти