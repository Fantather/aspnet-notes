Когда [[CLR]] встречает вызов метода, который ещё не был скомпилирован в машинный код, она поручает [[JIT|JIT-компилятору]] сделать это, в свою очередь [[JIT|JIT-компилятор]] проверяет [[IL-код]] на:
  - *Безопасность типов*
	- Нельзя присвоить `int` в `string`
	- Все операции выполняются над совместимыми типами
	- Корректность приведения типов

  - *Безопасность стека*
    [[IL-код|IL]] работает со стеком (каждая операция кладёт или берёт значение)
    [[CLR]] проверяет что
    - Количество элементов в стеке всегда правильное
    - Типы значений в стеке согласованы
    - Стек не переполняется и не остаётся пустым, когда не должен

  - *Доступ к памяти*
    - Нельзя обратиться к неинициализированной памяти
    - Нет выхода за границы массива
    - Запрещён небезопасный доступ без `unsafe`

  - *Доступ к полям и методам*
    - Можно вызывать только методы, к которым есть доступ (соблюдается `private`, `protected`)

  - *Корректность метаданных*
    - Все ссылки на типы, методы, поля должны указывать на существующие элементы
    - Типы должны соответствовать свой декларации

  - *Согласованность методов*
    - Правильное количество аргументов при вызове
    - Совпадение типов аргументов и возвращаемого значения с сигнатурой метода

  - *Исключения*
    - Правильные блоки `try`/`catch`/`finally` (на пример, `catch` нельзя использовать без `try`)
    - Стек после выхода из исключения согласован

  - *Оптимизация на уровне машинного кода*
    - Удаление неиспользуемого кода (dead code elimination)
    - Inline функций - замена вызова функции на её тело для ускорения
    - Оптимизация циклов - преобразование, упрощение итераций
    - Оптимизация доступа к памяти и регистрам
    - Построение оптимальной последовательности инструкций под конкретный процессор