- **Управление кодом**
  - Загружает [[IL-код]] в оперативную память
  - Перед запуском превращает [[IL-код|IL]] в машинные инструкции через [[JIT|JIT-компилятор]]
  - Может использовать разные стратегии компиляции (обычный, предварительная компиляция через NGen/R2R, tiered compilation)

- **Управление памятью**
  - Выделяет память под объекты
  - Следит, когда они перестают использоваться
  - Освобождает память через Garbage Collector(GC)
  - Делает код безопасным, не нужно освобождать память вручную

- **Безопасность и верификация кода**
  Когда [[CLR]] встречает вызов метода, который ещё не был скомпилирован в машинный код, она поручает [[JIT|JIT-компилятору]] сделать это, в свою очередь [[JIT|JIT-компилятор]] проверяет [[IL-код]] на:
  - *Безопасность типов*
	- Нельзя присвоить `int` в `string`
	- Все операции выполняются над совместимыми типами
	- Корректность приведения типов

  - *Безопасность стека*
    [[IL-код|IL]] работает со стеком (каждая операция кладёт или берёт значение)
    [[CLR]] проверяет что
    - Количество элементов в стеке всегда правильное
    - Типы значений в стеке согласованы
    - Стек не переполняется и не остаётся пустым, когда не должен

  - *Доступ к памяти*
    - Нельзя обратиться к неинициализированной памяти
    - Нет выхода за границы массива
    - Запрещён небезопасный доступ без `unsafe`

  - *Доступ к полям и методам*
    - Можно вызывать только методы, к которым есть доступ (соблюдается `private`, `protected`)

  - *Корректность метаданных*
    - Все ссылки на типы, методы, поля должны указывать на существующие элементы
    - Типы должны соответствовать свой декларации

  - *Согласованность методов*
    - Правильное количество аргументов при вызове
    - Совпадение типов аргументов и возвращаемого значения с сигнатурой метода

  - *Исключения*
    - Правильные блоки `try`/`catch`/`finally` (на пример, `catch` нельзя использовать без `try`)
    - Стек после выхода из исключения согласован

  - *Оптимизация на уровне машинного кода*
    - Удаление неиспользуемого кода (dead code elimination)
    - Inline функций - замена вызова функции на её тело для ускорения
    - Оптимизация циклов - преобразование, упрощение итераций
    - Оптимизация доступа к памяти и регистрам
    - Построение оптимальной последовательности инструкций под конкретный процессор

- **Обработка ошибок**
  - Реализует механизм исключений (`try`, `catch`, `finally`)
  - Делает обработку ошибок единообразной для всех языков .NET

- **Межъязыковое взаимодействие**
  - CLR гарантирует, что код на C#, VB.NET, F# и других языках может вызываться друг из друга
  - Это работает благодаря [[CTS|CTS]] и [[CLS|CLS]]

- **Поддержка многопоточности**
  - Управляет потоками
  - Даёт синхронизацию, блокировки, асинхронность

- **Интерпретируемость**
  CLR умеет вызывать код за пределами .NET
  - `P/Invoke` - вызов функций из нативных DLL
  - `COM Interop` - работа с COM-объектами

- **Метаданные и Отражение**
  - В CLR встроено хранение метаданных (описаний типов, методов, атрибутов)
  - Благодаря механизму Отражения(Reflection), можно динамически исследовать и даже генерировать код

- **Жизненный цикл приложений**
  - CLR отвечает за запуск и завершение приложений
  - Управляет доменами приложений (в .NET Framework) или сборками (в .NET Core/NET 5+)
  - Поддерживает горячую загрузку сборок
    Обычно программы используют все нужные DLL сразу при старте, но CLR умеет загружать сборку (DLL) прямо во время работы программы


Компиляторы в свою очередь используются как средства контроля синтаксиса и проверяют что исходный код имеет некий смысл, а затем генерируют на основе этого кода [[Управляемая сборка|Управляемую сборку]]


**Безопасность**
[[CLR]] следит за *Безопасностью типов*
 - операции могут выполняться только над совместимыми типами данных
   нельзя сложить число и ссылку на объект
   
 - методы и свойства можно вызывать только у объектов соответствующего типа
   нельзя вызвать метод для массива у строки
   
 - преобразования типов допускаются только если преобразование допустимо
  
  
   [[CLR]] следит за *Безопасностью использования памяти*
   - доступ к памяти возможен только в пределах допустимых границ (Нельзя выйти за пределы массива)

   - каждый объект изолирован и его данные не могут быть изменены извне (Нельзя случайно залезть в память другого объекта)

   - ссылки на объекты всегда указывают на корректные области памяти, исключая работу с «висячими» или недействительными указателями