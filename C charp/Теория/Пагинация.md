**Пагинация** — это разбиение большого набора данных (например, списка товаров, статей, результатов поиска) на отдельные, меньшие части, называемые **страницами**. Вместо того чтобы показывать пользователю все 1000 записей сразу, вы показываете только 10-20 на одной странице и предоставляете элементы управления для перехода между страницами («Предыдущая», «Следующая», «1», «2», «3» и т.д.).

Самый знакомый пример — поиск в Google. Когда вы ищете что-то, результаты выводятся не одним бесконечным списком, а страницами.

---

### Зачем нужна пагинация?

1.  **Производительность:**
    *   **Сервер БД:** Загрузка 20 записей из базы данных происходит гораздо быстрее, чем загрузка 10 000. Методы `Skip` и `Take` в LINQ, применяемые к `IQueryable`, транслируются в SQL-команды `OFFSET` и `FETCH` (или `LIMIT` в MySQL), что означает, что вся работа по выборке нужной страницы происходит на стороне СУБД, а не в коде приложения.
    *   **Клиент (браузер):** Передача меньшего объема данных по сети и их отрисовка в браузере занимают меньше времени и ресурсов.

2.  **Удобство пользователя (UX):**
    *   Пользователям психологически проще воспринимать и анализировать информацию небольшими порциями.
    *   Найти нужный элемент на странице с 20 элементами намного проще, чем в бесконечном списке.

3.  **Снижение нагрузки на память:**
    *   Ваше приложение (и база данных) не будет пытаться загрузить в оперативную память гигантский набор данных, что предотвращает утечки памяти и чрезмерную нагрузку.

---

### Как реализуется пагинация? (На примере C# и LINQ)

Ключевую роль в реализации играют методы `Skip` и `Take`, о которых шла речь в предыдущем ответе.

**Базовые параметры пагинации:**
*   **PageNumber (Номер страницы)** — какую страницу мы хотим показать (например, страница 2).
*   **PageSize (Размер страницы)** — сколько элементов помещается на одну страницу (например, по 10 товаров на страницу).

**Формула для запроса:**
```csharp
var pageNumber = 2;
var pageSize = 10;

// Запрос к данным (к базе данных через Entity Framework)
var pagedQuery = dataSource         // dataSource имеет тип IQueryable<T> или IEnumerable<T>
    .OrderBy(item => item.Id)       // !!! ВАЖНО: всегда должен быть указан порядок сортировки
    .Skip((pageNumber - 1) * pageSize) // Пропускаем все элементы с предыдущих страниц
    .Take(pageSize);                // Берем ровно столько элементов, сколько нужно для одной страницы

// Преобразуем в список (если это IQueryable, здесь будет выполнен SQL-запрос)
var pageItems = pagedQuery.ToList();
```

**Разбор формулы `Skip((pageNumber - 1) * pageSize)`:**
*   `pageNumber - 1`: Мы вычитаем единицу, потому что на **первой** странице нам не нужно ничего пропускать (`Skip(0)`). Для второй страницы нам нужно пропустить все элементы первой страницы.
*   `(pageNumber - 1) * pageSize`: Это общее количество элементов, которое нужно пропустить. Для страницы 2 и размера страницы 10: `(2-1)*10 = 10`. Мы пропускаем первые 10 элементов (всю первую страницу) и берем следующие 10 (вторую страницу).

---

### Пример в контексте веб-приложения (ASP.NET MVC)

Допустим, у нас есть модель `Product`.

**1. Модель представления для пагинации:**
Часто создается класс-обертка, который хранит и элементы для текущей страницы, и информацию о самой пагинации.
```csharp
public class PagedProductViewModel
{
    public IEnumerable<Product> Products { get; set; } // Элементы на текущей странице
    public int PageNumber { get; set; } // Текущая страница
    public int PageSize { get; set; } // Размер страницы
    public int TotalCount { get; set; } // Общее количество элементов
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize); // Всего страниц
}
```

**2. Метод в контроллере:**
```csharp
public ActionResult Index(int pageNumber = 1, int pageSize = 10)
{
    // Получаем запрос из базы данных
    var query = _context.Products.OrderBy(p => p.Name);

    // Получаем общее количество элементов (для этого делается отдельный запрос COUNT(*))
    var totalCount = query.Count();

    // Применяем пагинацию к данным
    var products = query.Skip((pageNumber - 1) * pageSize)
                       .Take(pageSize)
                       .ToList();

    // Создаем модель представления
    var viewModel = new PagedProductViewModel
    {
        Products = products,
        PageNumber = pageNumber,
        PageSize = pageSize,
        TotalCount = totalCount
    };

    return View(viewModel);
}
```

**3. Представление (View):**
В представлении можно вывести список продуктов из `Model.Products` и построить навигацию, используя свойства `Model.PageNumber`, `Model.TotalPages`. Ссылки на другие страницы будут вести на тот же action контроллера, но с другим параметром `pageNumber`.

---

### Альтернативы пагинации

*   **Бесконечная прокрутка (Infinite Scroll):** Контент подгружается динамически, когда пользователь доходит до конца страницы (например, в ленте Instagram или Twitter). **Под капотом часто используется тот же механизм** (`Skip` и `Take`), но с более сложной логикой на клиенте.
*   **Курсорная пагинация (Keyset Pagination):** Более производительная альтернатива для очень больших данных, основанная на запомненном значении последнего элемента предыдущей страницы (например, `WHERE Id > lastSeenId ORDER BY Id LIMIT 10`). Она лишена недостатков `OFFSET`, который сильно тормозит на больших смещениях.

### Итог

**Пагинация** — это не просто кнопки «Вперед-назад», а стратегия обработки данных, направленная на повышение производительности и удобства пользователя. Методы LINQ `Skip` и `Take` являются основными инструментами для ее реализации на стороне сервера в C#.