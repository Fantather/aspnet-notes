## Основные проблемы многопоточности

**Состояние гонки (Race Condition)**
  Ситуация, когда поведение программы зависит от того, в каком порядке выполняются потоки.
  *Пример:* Два потока одновременно пытаются изменить возраст пользователя. Результат зависит от того, кто "успеет" последним записать данные в память.

**Грязное чтение (Dirty Read / Torn Read)**
  Ситуация, когда один поток считывает данные объекта, пока другой поток находится в процессе их обновления.
  *Пример:* Поток А начал обновлять `User` (поменял имя, но еще не успел поменять телефон). Поток Б в этот момент прочитал `User`. В итоге у Потока Б объект с новым именем, но старым телефоном. Данные несогласованны.



## Стратегии защиты данных
### 1.Неизменяемость (Immutability)
Самый надежный и простой способ обеспечения безопасности. Если объект нельзя изменить после создания, то конфликты при чтении невозможны. В C# для этого идеально подходит тип [[Csharp Records (Тип запись)|record]].

**Принципы**
  **Использование record**
  Вместо классов используем позиционные записи. Они неизменяемы по умолчанию и предоставляют синтаксис для безопасного копирования.

  **Недеструктивная мутация (with)**
  Для изменения данных используется оператор `with`, который создает клон объекта с заменой указанных свойств, оставляя оригинал нетронутым.

**Пример реализации**
```csharp
// Одной строки достаточно для создания неизменяемой модели
public record User(Guid Id, string Name, string Phone, int Age);

// Логика обновления
public void UpdateUser(Guid id, string newName)
{
    var oldUser = _users[id];

    // Магия record: берем старого, меняем только имя, остальные поля копируются сами
    // Это и есть безопасный Copy-on-Write
    var newUser = oldUser with { Name = newName };

    // Атомарно подменяем ссылку в словаре
    _users[id] = newUser;
}
```

### 2. Конкурентные коллекции (Concurrent Collections)
Специальные структуры данных в .NET, оптимизированные для работы в многопоточной среде без явных блокировок (`lock`).

**ConcurrentDictionary**
Потокобезопасная реализация словаря.
- `TryAdd` — пытается добавить, если ключа нет.
- `TryRemove` — пытается удалить и вернуть значение.
- `TryGetValue` — безопасное чтение.
- `AddOrUpdate` — добавляет или обновляет значение (атомарно).

**Важное предупреждение**
`ConcurrentDictionary` гарантирует безопасность только **структуры словаря** (добавление/удаление ключей). Он _не_ защищает свойства объектов, хранящихся внутри, если они изменяемы (`mutable`).

_Если вы достали объект из словаря и начали менять его свойства (`user.Age++`), ConcurrentDictionary вас не защитит от гонки потоков._

### 3. Блокировки (Locking)
Классический подход, когда доступ к ресурсу разрешается только одному потоку за раз.

**Использование lock**
```C#
private readonly object _lock = new object();

public void UpdateUser(Guid id, string newName)
{
    lock (_lock)
    {
        // Внутри этого блока может находиться только один поток
        var user = _users[id];
        user.Name = newName;
    }
}
```

**Минусы**
- Снижает производительность (потоки ждут в очереди).
- Риск взаимной блокировки (Deadlock)

## Рекомендации для In-Memory репозиториев
**Используй Immutable Models**
Сделай модели `User` неизменяемыми (`init` properties). При обновлении заменяй объект целиком. Это решает проблему "грязного чтения".

**Используй ConcurrentDictionary**
Для хранения списка объектов. Это решает проблему одновременного добавления/удаления.

**Избегай List в Singleton**
Обычный `List<T>` не потокобезопасен. При одновременной записи массив внутри списка может разрушиться. Используй `ConcurrentBag<T>`, `ImmutableList<T>` или защищай `List<T>` через `lock`.

**Возвращай копии (Snapshots)**
Метод `GetAll()` должен возвращать новую коллекцию или `IEnumerable`, который не сломается, если в исходный словарь добавят элемент во время перебора.

_ConcurrentDictionary.Values делает это автоматически — он создает мгновенный снимок значений._