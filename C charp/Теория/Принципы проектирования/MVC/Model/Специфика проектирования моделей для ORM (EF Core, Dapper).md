Главная сложность при работе с БД — разделение двух сценариев жизни объекта:
1.  **Creation**: Создание совершенно новой сущности в коде для последующей вставки в БД (`INSERT`).
2.  **Materialization (Hydration)**: Восстановление объекта из данных, полученных из БД (`SELECT`).

## 1. Проблема Идентификаторов (Identity Strategy)
В базе данных `Id` — это уникальный ключ существующей строки. В C# объекте `Id` не может меняться после создания, но должен быть доступен для записи ORM при материализации.

### Конфликт генерации
* **Сценарий**: В конструкторе класса прописано `Id = Guid.NewGuid()`.
* **Проблема**: При чтении из БД ORM вызывает конструктор, создавая новый случайный `Id`. Затем ORM должна *перезаписать* его тем значением, которое пришло из базы. Если свойство `Id` не имеет сеттера (или `init`), ORM выдаст исключение.

### Стратегии генерации ключей
* **Client-Side (Guid)**: Идентификатор генерируется в C# коде.
    * *Плюс*: ID известен до сохранения в базу. Удобно для связанных данных.
    * *Реализация*: Инициализация в конструкторе или авто-свойстве.
* **Database-Side (Identity/Sequence)**: Идентификатор генерирует БД (обычно `int` или `long`).
    * *Плюс*: Меньше размер индекса.
    * *Минус*: ID равен `0` до момента вызова `SaveChanges()`.
    * *Реализация*: Свойство `Id` в C# оставляется пустым (`default`), БД заполняет его при вставке, ORM обновляет объект.

## 2. Entity Framework Core (EF Core)
EF Core — мощный инструмент, использующий рефлексию (Reflection) и доступ к приватным полям.

### Требования к конструкторам
EF Core умеет использовать параметризованные конструкторы, но имеет особенности:
* **Сопоставление**: Имена аргументов конструктора должны совпадать с именами свойств (camelCase сопоставляется с PascalCase). Например, аргумент `string name` запишется в свойство `Name`.
* **Пустой конструктор**: Часто требуется `protected` или `private` конструктор без параметров. Он нужен EF для создания "пустой болванки" объекта перед заполнением полей через рефлексию, если параметризованный конструктор слишком сложен или отсутствует.

### Инкапсуляция (Private Setters & Backing Fields)
EF Core позволяет делать богатую доменную модель (Rich Domain Model), скрывая данные.

* **Private Setters**: Свойства могут иметь `private set`. EF Core всё равно сможет записать в них данные при чтении из БД.
* **Backing Fields**: Можно вообще не создавать свойство, а мапить колонку таблицы напрямую на приватное поле `_fieldName`.

```csharp
public class User
{
    // EF Core сам найдет и заполнит это поле, даже если сеттер приватный
    public Guid Id { get; private set; } 

    // Поле для инкапсуляции коллекции
    private readonly List<Order> _orders = new();
    
    // Публичный доступ только для чтения (IReadOnlyCollection)
    public IReadOnlyCollection<Order> Orders => _orders.AsReadOnly();

    // Конструктор для создания нового пользователя (Creation)
    public User(string name)
    {
        Id = Guid.NewGuid(); // Client-side generation
        Name = name;
    }

    // Приватный конструктор для EF Core (Materialization)
    // EF вызовет его, а затем через рефлексию заполнит свойства
    private User() { } 
}
````

## 3. Dapper (Micro-ORM)
Dapper — легковесная библиотека, работающая ближе к SQL. Она меньше полагается на магию рефлексии и больше на соглашения.

### Особенности маппинга
- **Конструкторы**: Dapper пытается сопоставить колонки из SQL-запроса (`SELECT Id, Name ...`) с аргументами конструктора. Порядок и типы важны.
    
- **Init-only properties**: Dapper отлично работает со свойствами `init`, что позволяет создавать иммутабельные объекты.
    
- **Private Setters**: По умолчанию Dapper **не умеет** заполнять свойства с `private set`. Ему нужны либо публичные сеттеры, либо конструктор, принимающий все поля.

```C#
// Идеальная модель для Dapper (Immutable)
public class User
{
    // Dapper заполнит это через init при создании объекта
    public Guid Id { get; init; }
    public string Name { get; init; }

    // Конструктор, покрывающий все поля (Dapper использует его)
    public User(Guid id, string name)
    {
        Id = id;
        Name = name;
    }
}
```


## 4. Сводные правила (Best Practices)
1. **Используй `init` для ID**: Это золотая середина. Свойство доступно для инициализации при материализации (и EF, и Dapper), но защищено от изменения в обычном коде.
    
2. **Разделяй логику**: Не пиши бизнес-логику в сеттерах свойств, которые маппятся на БД, так как эта логика будет срабатывать при каждом чтении из базы (что избыточно и опасно).
    
3. **Примитивы**: Старайся хранить в свойствах, маппируемых на БД, примитивные типы (`string`, `int`, `Guid`). Сложные объекты-значения (Value Objects) требуют настройки конвертеров.
    
4. **Навигационные свойства**: В EF Core свойства-ссылки на другие сущности (`public List<Order> Orders { get; set; }`) должны быть `virtual`, если нужен механизм Lazy Loading (ленивая загрузка).
    

### Универсальный пример (EF Core + Dapper Friendly)
```C#
public class Product
{
    // Init позволяет установить ID при загрузке из БД
    public Guid Id { get; init; } 
    
    // Private set защищает от изменений извне, но требует настройки для Dapper
    // Для универсальности лучше использовать init или защищенный метод изменения
    public string Name { get; private set; }
    public decimal Price { get; private set; }

    // Конструктор для создания новой сущности (Бизнес-логика)
    public Product(string name, decimal price)
    {
        Id = Guid.NewGuid();
        Name = name;
        Price = price;
    }

    // Конструктор для ORM (принимает все данные из БД)
    // Dapper будет использовать его для маппинга колонок на аргументы
    // EF Core тоже умеет его использовать
    public Product(Guid id, string name, decimal price)
    {
        Id = id;
        Name = name;
        Price = price;
    }
    
    // Метод бизнес-логики
    public void UpdatePrice(decimal newPrice)
    {
        if(newPrice < 0) throw new ArgumentException("...");
        Price = newPrice;
    }
}
```