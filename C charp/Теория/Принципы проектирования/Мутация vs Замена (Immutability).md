## Проблема мутации (In-Place Mutation)
Когда мы меняем свойства объекта, который находится в общем доступе (например, в Singleton-репозитории), возникает риск состояния гонки (Race Condition).
* **Сценарий**: Поток №1 меняет `Name`. Поток №2 читает объект. Поток №1 меняет `Age`.
* **Результат**: Поток №2 получил объект с новым именем, но старым возрастом. Данные несогласованны.

## Решение: Логика замены (Replacement)
Вместо изменения полей существующего объекта, мы создаем **новый экземпляр** и заменяем ссылку на него в хранилище.

### Преимущества
1.  **Атомарность**:
  Операция присваивания ссылки (`dictionary[key] = newValue`) выполняется за один такт процессора (условно) и не может быть прервана. Читатель получит либо строго старую версию, либо строго новую.

2.  **Snapshot Isolation**:
  Если кто-то получил ссылку на `User` до обновления, он может спокойно с ней работать. Его данные не изменятся неожиданно, так как репозиторий теперь ссылается на *другой* участок памяти.

### Реализация
Для этого модель должна позволять установку ID при инициализации (свойство `init` или конструктор с ID).

**Пример метода Update:**
```csharp
public bool Update(Guid id, User incomingData)
{
    if (!_users.ContainsKey(id)) return false;

    // Создаем копию с новыми данными, но старым ID
    var newUser = new User(id, incomingData.Name, incomingData.Phone, incomingData.Age);
    
    // Перезаписываем ссылку в словаре
    _users[id] = newUser;
    return true;
}
````