![[Pasted image 20250904200308.png]]

альтернативный ключ для ускорения поиска если у нас по нему часто ищут
не стоит добавлять на те поля которые часто меняются

Если много сутностей - так псать неудобно. Создается публичный класс и закрывается нужным типом 
![[Pasted image 20250904200733.png]]

И тут настраиваем все что входит в таблицу
Настройка конкретной таблицы
![[Pasted image 20250904200816.png]]

___
### Указываем настройки моделей
![[Pasted image 20250904201510.png]]



>[!info] Пример
>
```c#
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

public class ProductConfig : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> tb)
    {
        // Имя таблицы
        tb.ToTable("Products");

        // Первичный ключ
        tb.HasKey(p => p.Id);

        // Поля
        tb.Property(p => p.Name)
          .IsRequired()
          .HasMaxLength(200);

        tb.Property(p => p.Price)
          .HasColumnType("decimal(18,2)")
          .IsRequired();

        // Альтернативный ключ (например, если часто ищут по артикулу)
        tb.HasAlternateKey(p => p.Sku);

        // Индексы
        tb.HasIndex(p => p.Name); 
    }
}

```

### Регистрация конфигурации в `DbContext`
```c#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.ApplyConfiguration(new ProductConfig());
}


```

#резюме 
- Конфигурация отдельно от самой модели (`Product` остаётся чистой POCO).
    
- Удобно масштабировать, если много сущностей.
    
- Можно настраивать ключи, индексы, ограничения, типы колонок и т.д.
___
