Отношение One-to-One (1:1) означает, что каждая запись в одной таблице связана с ровно одной записью в другой таблице, и наоборот. Это встречается, например, когда у вас есть User и UserProfile, и каждому пользователю соответствует ровно один профиль

```c#
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }

    // Навигационное свойство для связи 1:1
    public UserProfile Profile { get; set; }
}

public class UserProfile
{
    public int Id { get; set; } // будет и PK, и FK к User
    public string Bio { get; set; }

    // Навигационное свойство обратно к User
    public User User { get; set; }
}
```


Конфигурация через Fluent API
```C#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>()
        .HasOne(u => u.Profile)        // User имеет один Profile
        .WithOne(p => p.User)          // Profile имеет одного User
        .HasForeignKey<UserProfile>(p => p.Id); // FK в UserProfile
}
```
`HasForeignKey<UserProfile>(p => p.Id)` - значит, что UserProfile.Id будет одновременно первичным ключом и внешним ключом на User.Id.


Конфигурация через Data Annotations (альтернатива)
```c#
public class UserProfile
{
    [Key]
    [ForeignKey("User")] // указывает, что PK также является FK на User
    public int Id { get; set; }
    public string Bio { get; set; }

    public User User { get; set; }
}
```
___
Примеры
```C#
var user = new User
{
    Name = "Olga",
    Profile = new UserProfile
    {
        Bio = "Developer"
    }
};

context.Users.Add(user);
context.SaveChanges();

// Получение данных
var userWithProfile = context.Users
    .Include(u => u.Profile)
    .FirstOrDefault(u => u.Name == "Olga");
```


**Итоги**
- FK обычно в зависимой сущности
  В нашем примере зависимая — UserProfile, основная — User
  
- PK может быть FK
  Это обычный паттерн для One-to-One
  
- Include нужен, если вы хотите подгружать связанную сущность, иначе EF Core не подтянет Profile.