```jsx
import ReactDOM from 'react-dom/client';

import React from 'react';

class Greeting extends React.Component {

  constructor(props) {

    super(props);

    this.state = { };

    }

    onTextChange = (event) => {

      this.setState({ 

        name: event.target.value

       });

    };   

  render() {

    const text = this.state.text || this.props.text;

    return (

      <div>

      <h1>{this.props.title}</h1>

      <input

        type="text"

        placeholder="Enter your name"

        value={this.state.name}

        onChange={this.onTextChange}

      />

      <p>Hello, {this.state.name ? this.state.name : 'stranger'}!</p>

    </div>

    );

  }

}

function App() {

  return (

    <div>

      <h1>First Lesson</h1>

      <Greeting name=""/>

    </div>

  );

}
```

![[Pasted image 20251210194713.png]]

выводим значения и оно сразу отображет

тут есть ошибка, но про ключи говорим потом


доступ к свойсвам через this.props
и к состояния через this.state
___

жизненній цикл

1. вставка из DOM
2. обновление (при вызове)
3. удаление из DOM

Реакт работает перед обновленим DOM

после первонач вставки и фиксации компонента выполняется 

componentDidMount

![[Pasted image 20251210195250.png]]
отличный вариант что бы добавить прослушивания и тд 

перед улаением компонента вызывается 
```jsx
  componentWillUnmount() {}
```

![[Pasted image 20251210195352.png]]

самый простой пример - таймер
там должно очищать все исп. ресурсы

для обновления
`  getSnapshotBeforeUpdate(){ }`

каждый раз когда компонент был обновлен
`  componentDidUpdate(){}`
получишь копию преведущего обновления


  будущее состояние которое можно сравнить с текущим
  shouldComponentUpdate(){}
___
зачастую испольщуются два
``` jsx
  componentDidMount() {}

  

  componentDidUpdate(){}
```


___
```jsx
import React from "react";

function App() {

  return (

    <div>

      <h1>First Lesson</h1>

      <TextAreaCounter text="Alex" />

    </div>

  );

}

class TextAreaCounter extends React.Component {

  constructor(props) {

    super(props);

    this.state = {};

  }

 onTextChange = (event) => {

      this.setState({

        name: event.target.value

       });

    };  

  componentDidMount() {

    console.log('componentDidMount');

  }

  componentWillUnmount() {

    console.log('componentWillUnmount');

  }

  componentDidUpdate(prevProps, prevState, snapshot) {

    console.log('componentDidUpdate ', prevProps, prevState,

      snapshot);

  }

  getSnapshotBeforeUpdate(prevProps, prevState) {

    console.log('getSnapshotBeforeUpdate', prevProps, prevState);

    return 'hello';

  }

  shouldComponentUpdate(newProps, newState) {

    console.log('shouldComponentUpdate ', newProps, newState);

    return true;

  }

  render(){

    return(

        <div>

          <input type="text" value={this.state.name ? this.state.name : ''}  onChange={this.onTextChange} />

          <div>Hello, {this.state.name ? this.state.name : 'Empty'}</div>

        </div>

    );

  }

}
export default App;
```

после загрузки в консоли будет только єто

![[Pasted image 20251210195814.png]]

если что то введем

![[Pasted image 20251210195818.png]]

вызывается

![[Pasted image 20251210195930.png]]


![[Pasted image 20251210195850.png]]

позволяет передать любую инфу в виде снимков в следующий метод

и в конце вызывается 
![[Pasted image 20251210195919.png]]
который проверяет работает ли 
___
не вызывался только 
![[Pasted image 20251210195941.png]]
он вызовется при зкрытии страницы или изменения самого компонента
___
![[Pasted image 20251210200005.png]]

обработчик вызывается когда пользователь вводит текст
если кто то вызовет метод вне компонента мы уже не сможем обеспечить благополучную работу

___