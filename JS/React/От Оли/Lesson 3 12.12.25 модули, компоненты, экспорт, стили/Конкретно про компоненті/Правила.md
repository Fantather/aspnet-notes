Все компоненты должны начинаться с большой буквы

![[Pasted image 20251212183204.png]]

ибо реакт определяет компоненты по регистру
если строчный - он подумает что это html
___
Любой компонент может вернуть лишь один корневой елемент
![[Pasted image 20251212183335.png]]
что бы древо оставалось предсказуемым

Реакт компонент это чистая функция

Пример чистой и простой ф-ции
![[Pasted image 20251212183443.png]]

зачем тогда в реакте компонент чистыс?
 он может вызвать его много раз, вхолостую и без вывода. Делать часто рендер. Если будет какой то побочный ефект - будут ошибки что слодно отслеживать
он принимает пропс и возвращает один компонент

## 1. Нельзя изменять стейт (State) напрямую (Мутация)

React отслеживает изменения через сравнение ссылок на объекты. Если вы измените свойство объекта напрямую, ссылка останется той же, и React не поймет, что нужно перерисовать компонент.

- **Плохо:**
    
    JavaScript
    
    ```
    const [user, setUser] = useState({ name: 'Ivan', age: 25 });
    
    // ОШИБКА: Прямая мутация. React не увидит изменений.
    user.name = 'Dmitry';
    ```
    
- **Хорошо:**
    
    JavaScript
    
    ```
    // Создаем новый объект (копию) с новыми данными
    setUser({ ...user, name: 'Dmitry' });
    ```
    

## 2. Нельзя вызывать побочные эффекты (Side Effects) в теле компонента

Тело функционального компонента (всё, что происходит до `return`) — это **этап рендеринга**. Он должен быть чистым (Pure). Код здесь может запускаться много раз даже без видимых изменений на экране.

Запрещено в теле функции:

- Делать HTTP-запросы (fetch).
    
- Изменять глобальные переменные (`window.something = ...`).
    
- Изменять DOM напрямую (`document.title = ...`).
    
- Запускать таймеры (`setTimeout`).
    
- **Где это делать:** Внутри хука `useEffect` или в обработчиках событий (например, `onClick`).
    

## 3. Нельзя нарушать правила хуков (Rules of Hooks)

Хуки (`useState`, `useEffect` и др.) полагаются на **порядок вызова**. React запоминает, какой стейт принадлежит какому `useState`, просто считая их по порядку: "первый хук, второй хук...".

- **Нельзя** вызывать хуки внутри условий (`if`).
    
- **Нельзя** вызывать хуки внутри циклов (`for`).
    
- **Нельзя** вызывать хуки внутри вложенных функций.
    
- **Плохо:**
    
    JavaScript
    
    ```
    if (isAdmin) {
      const [data, setData] = useState(null); // ОШИБКА: Порядок собьется, если isAdmin станет false
    }
    ```
    
- **Хорошо:** Все хуки должны быть на верхнем уровне функции.
    

## 4. Нельзя изменять пропсы (Props)

Пропсы — это данные "только для чтения" (Read-Only), которые компонент получает от родителя. Попытка их изменить нарушает принцип однонаправленного потока данных.

- **Плохо:**
    
    JavaScript
    
    ```
    function Button(props) {
      props.text = "New Text"; // ОШИБКА: Пропсы неизменяемы
      return <button>{props.text}</button>;
    }
    ```
    
- **Как надо:** Если нужно изменить данные на основе пропсов, создайте локальный стейт или вычислите новую переменную внутри компонента.
    

## 5. Нельзя вызывать `setState` во время рендеринга без условий

Это приведет к бесконечному циклу (Infinite Loop). Логика такая: Компонент рендерится -> Вызывается `setState` -> React видит обновление и запускает ререндер -> Компонент рендерится -> Снова `setState`... и так до зависания браузера.

- **Плохо:**
    
    JavaScript
    
    ```
    function Counter() {
      const [count, setCount] = useState(0);
    
      setCount(count + 1); // ОШИБКА: Бесконечный ререндер сразу при запуске
    
      return <div>{count}</div>;
    }
    ```
    
- **Исключение:** В очень редких случаях это допустимо внутри условия `if` для корректировки состояния перед отрисовкой (pattern "derived state"), но новичкам лучше этого избегать.
    

## 6. Нельзя использовать случайные ключи (Keys) при рендеринге списков

Ключ (`key`) помогает React понять, какой элемент списка изменился, добавился или исчез.

- **Плохо:** `key={Math.random()}`. При каждом рендере ключи будут новыми. React будет думать, что это **абсолютно новые** элементы, удалять старые из DOM и создавать новые. Это убивает производительность и сбрасывает фокус в инпутах.
    
- **Плохо:** Использовать индекс массива (`index`), если порядок элементов может меняться (сортировка, удаление).
    
- **Хорошо:** Использовать уникальные ID из базы данных (`id`).
    

## 7. Нельзя обращаться к реальному DOM, минуя React

React использует Virtual DOM. Если вы измените что-то через `document.getElementById('root').remove()`, React потеряет синхронизацию с реальностью и приложение сломается при следующем обновлении.

- **Как надо:** Если нужен доступ к элементу (например, для фокуса или измерения размеров), используйте `useRef`.
