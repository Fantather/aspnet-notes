## Проблема "Магических строк" и Тихие ошибки
**Магическая строка** — это строковый литерал (например, `"email"` или `"password"`), написанный прямо в коде компонента.
  
**В чем опасность:**
  Если ты опечатаешься в строке (напишешь `"emial"` вместо `"email"`), JavaScript **не выдаст ошибку**.
  
**Типы ошибок:**
  * **Громкая ошибка (Crash):** Приложение падает, экран красный. Это *хорошо*, потому что баг сразу виден.
  * **Тихая ошибка (Silent Bug):** Приложение работает, но данные не сохраняются или сохраняются не туда. Это *плохо*, так как баг можно искать часами.

**Где возникают тихие ошибки:**
  * В атрибуте `name` у `<input>`.
  * В функции обновления стейта (через `[e.target.name]`).
  * При создании начального стейта `useState`.

## Решение: Модель данных (Single Source of Truth)
Чтобы избежать опечаток, мы выносим имена полей в отдельный объект-константу. Это **Словарь полей**.

**Принцип:**
  Мы не пишем строки руками. Мы ссылаемся на свойства объекта. Если ты опечатаешься в названии свойства (например, `FIELD.EMIAL`), редактор кода или сборщик сразу подсветят ошибку.

```javascript
// model.js
export const FIELD = {
  TITLE: "title",
  COUNT: "count",
  IS_ACTIVE: "isActive"
};
```

## Паттерн "Фабрика" (Factory Pattern)
Вместо того чтобы хардкодить структуру объекта внутри компонента (в `useState`), мы создаем функцию, которая генерирует этот объект.

**Зачем это нужно:**
- _Гарантия структуры:_ Мы уверены, что объект всегда имеет все нужные поля.
- _Дефолтные значения:_ Логика пустых значений (null, "", 0) инкапсулирована в одном месте.
- _Масштабируемость:_ Если добавится новое поле, мы добавим его только в фабрику, а не во все 50 компонентов, где используется этот объект.

``` JavaScript
// model.js
// Используем Computed Property Names (квадратные скобки)
export function createItem(title = "", count = 0) {
  return {
    [FIELD.TITLE]: title,
    [FIELD.COUNT]: count,
    [FIELD.IS_ACTIVE]: false // Значение по умолчанию, скрытое от внешнего мира
  };
}
```

## 4. "Гибридный подход" в React-компоненте
Это баланс между _надежностью данных_ и _читаемостью кода_.

#### А. Для Логики (Надежность)
Везде, где происходит **запись** данных или связывание с HTML, используем **Константы**. Это "цементирует" связь между интерфейсом и стейтом.

```JavaScript
// В JSX
<input 
  name={FIELD.TITLE} // Гарантирует, что name совпадает с ключом в стейте
  onChange={handleChange} 
/>

// В функции обновления (Generic Handler)
setState(prev => ({
  ...prev,
  [target.name]: target.value // Безопасно обновляет поле по ключу
}));
```

#### Б. Для Чтения (Удобство)
Внутри верстки (JSX) использование констант `state[FIELD.TITLE]` делает код громоздким. Поэтому для **чтения** мы используем деструктуризацию.

``` JavaScript
const { title, count } = state; // Вытаскиваем данные в переменные

return (
  // Читается чисто и понятно
  <input value={title} ... />
);
```


**Итог:**
- _Модель_ хранит имена полей (защита от опечаток)
- _Фабрика_ создает структуру данных (защита от `undefined`)
- _Компонент_ использует модель для связывания `input` <-> `state`