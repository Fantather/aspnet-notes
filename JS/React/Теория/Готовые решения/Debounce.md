То, что вы описываете («меняться state начинает, когда пользователь перестал печатать»), в программировании называется паттерном **Debounce** (устранение дребезга)

Чтобы `setTimeout` работал так, как вы ожидаете, необходимо **очищать (отменять) предыдущий таймер**, если новое событие пришло раньше, чем сработал старый.

Логика должна быть такой:

1. Пользователь ввел "А". Мы запланировали обновление через 500 мс (id таймера = 1).
    
2. Пользователь ввел "Б" (через 100 мс).
    
3. Мы видим, что таймер (id = 1) еще ждет. Мы делаем `clearTimeout(1)`.
    
4. Мы планируем новое обновление через 500 мс (id таймера = 2).
    

Тогда сработает только последний таймер.

**Пример корректной реализации (Debounce):**

JavaScript

```
// Нам нужно где-то хранить идентификатор таймера (в this.timerId)
handleChange = (event) => {
    const value = event.target.value; // Сохраняем значение сразу!

    // Если таймер уже запущен — отменяем его
    if (this.timerId) {
        clearTimeout(this.timerId);
    }

    // Запускаем новый таймер
    this.timerId = setTimeout(() => {
        this.setState({ text: value });
    }, 500);
}
```

### 3. Техническое уточнение про `event`

В вашем исходном коде есть комментарий:

// Спустя 500мс ссылка на event может быть потеряна или неактуальна

Это критически важный момент для React (особенно версий до 17), связанный с **Event Pooling** (пулом событий).

- В старых версиях React объект `event` переиспользовался ради производительности.
    
- Как только синхронный код обработчика `handleChange` заканчивался, React «очищал» объект `event`, обнуляя его свойства (включая `target`).
    
- Когда через 500 мс срабатывал `setTimeout`, callback пытался обратиться к `event.target.value`. Но к этому моменту `event.target` уже был `null`.
    

Решение:

Нужно сохранить значение строки в локальную переменную до запуска setTimeout (как в примере выше: const value = event.target.value), чтобы внутри замыкания таймера использовать уже строку, а не ссылку на динамический объект события.

### Резюме

1. Ваше понимание верно: приведенный код просто выполнит все обновления с задержкой (Delay), а не сгруппирует их.
    
2. Чтобы реагировать на "остановку ввода", нужно использовать `clearTimeout` для сброса предыдущего таймера (паттерн Debounce).
    
3. Использовать `event.target.value` внутри асинхронной функции (`setTimeout`) небезопасно из-за механизма работы событий в React (особенно старых версиях) — нужно кэшировать значение в переменную.
    

Вам помочь реализовать правильный Debounce для вашего компонента?