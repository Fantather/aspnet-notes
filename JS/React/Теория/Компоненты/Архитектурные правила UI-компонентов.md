### Разделение ответственности (Logic vs View)
Это означает, что компонент не должен знать, откуда берутся данные или как они обрабатываются. Он должен знать только то, как их отобразить

**Правило:** Вся бизнес-логика (запросы к API, сложные вычисления, валидация форм) должна быть вынесена за пределы JSX-компонента

**Реализация:** Используй **Custom Hooks** (пользовательские хуки)
 _Плохо:_ Компонент `UserProfile` внутри себя вызывает `fetch('/api/user')`
 _Хорошо:_ Компонент `UserProfile` вызывает хук `useUser()`, который возвращает `{ user, isLoading }`. Компонент просто рендерит это состояние

### Принцип единственной ответственности (Single Responsibility Principle — SRP)
Каждый компонент должен отвечать за одну логическую часть интерфейса

**Правило:** Если компонент занимает больше 100–150 строк или требует сложного наименования (например, `UserCardWithEditFormAndStatistics`), его нужно декомпозировать (разбить на части)

**Признаки нарушения:** В компоненте слишком много эффектов (`useEffect`), слишком много стейтов (`useState`) или JSX-разметка имеет глубокую вложенность

### Композиция вместо наследования (Composition over Inheritance)
Это фундаментальный принцип React. Вместо того чтобы создавать бесконечное количество пропсов для конфигурации компонента, используй вложенность

**Правило:** Используй пропс `children` для передачи контента внутрь компонента-обертки.

**Пример:**
_Плохо:_ 
```jsx
<Modal contentText="Привет" footerButtons={[<Btn>Ok</Btn>]} />
```

_Хорошо:_
```JavaScript
<Modal>
	<ModalHeader>Привет</ModalHeader>
	<ModalFooter>
		<Button>Ok</Button>
	</ModalFooter>
</Modal>
```


### Чистота функции рендеринга (Render Purity)
Функция компонента должна быть чистой (Pure). Это значит, что при одних и тех же входных данных (props) она всегда должна возвращать один и тот же результат (JSX)
А так же функция не должна вызывать **Side Effects** (побочные эффекты) До рендера, это достигается через изоляцию побочных эффектов в [[useEffect]]
- Нельзя делать HTTP-запросы напрямую
- Нельзя изменять глобальные переменные
- Нельзя подписываться на события (DOM events) напрямую

**Правило**
 Все побочные эффекты должны находиться строго внутри `useEffect` или обработчиков событий (event handlers), потому что `useEffect` выполняется После рендера компонента

### Принцип единственного источника истины (Single Source of Truth)
Избегай дублирования состояния

**Правило:** Если значение можно вычислить на основе пропсов или другого стейта, не создавай для него отдельный `useState`

**Пример:**
- _Плохо:_ У тебя есть стейт `firstName` и `lastName`, и ты создаешь третий стейт `fullName` и пытаешься их синхронизировать через `useEffect`
- 
- _Хорошо:_ Вычисляй переменную прямо при рендере: `const fullName = ${firstName} ${lastName};`. Это называется **Derived State** (производное состояние)

### Проектирование API компонента (Props Design)
Пропсы — это публичный интерфейс компонента. Он должен быть понятным и предсказуемым

**Правило 1 (Boolean):** Избегай отрицательных названий флагов
- _Плохо:_ `isNotDisabled={true}` (двойное отрицание сложно читать)
- _Хорошо:_ `isEnabled={true}` или просто `disabled`

**Правило 2 (Data):** Передавай данные объектами, если они связаны, но не передавай лишнего
- Если компоненту нужна только аватарка, не передавай ему весь объект `user` на 50 полей. Это облегчит мемоизацию (`React.memo`) и тестирование

**Правило 3 (Callbacks):** Называй функции-обработчики, начиная с `on` (например, `onClose`, `onSubmit`, `onValueChange`), чтобы четко обозначить, что это реакция на событие


### Изоляция стилей
Компонент не должен влиять на стили других компонентов.
**Правило**
  Используй CSS Modules, CSS-in-JS (Styled Components, Emotion) или утилитарные классы (Tailwind), чтобы стили компонента были инкапсулированы и не «протекали» в глобальную область видимости.


### Итог
1. **UI/Logic Separation:** Компонент отвечает за View. Логика выносится в Custom Hooks или утилиты

2. **SRP (Single Responsibility):** Один компонент = одна задача. Большие компоненты декомпозируем

3. **Composition:** Используй `children` и слоты вместо создания «God-компонентов» с десятком конфигурационных пропсов

4. **Purity:** Рендер-функция чиста. Сайд-эффекты (API, подписки) строго в `useEffect` или Event Handlers

5. **Single Source of Truth:** Не дублируй данные в стейте. Используй вычисляемые переменные (Derived State)

6. **Explicit Props:** Пропсы должны быть очевидными. Избегай передачи лишних данных. Именование хендлеров через `onAction`