**Чистота фазы рендера**
Тело функции компонента выполняется **во время** каждого рендера. Оно должно быть быстрым и синхронным
Тяжелые вычисления здесь блокируют отрисовку (используй `useMemo` для них)

**Порядок выполнения**
- *Сначала*: Вычисление тела компонента и возврат JSX
- *Затем*: Обновление DOM и отрисовка браузером (Paint)
- *В конце*: Запуск `useEffect` (асинхронно, чтобы не блокировать UI)
- *Исключение* (`useLayoutEffect`)
  Если нужно изменить DOM _синхронно_ до того, как пользователь увидит обновление (например, измерить размеры элемента и тут же перерисовать), используется `useLayoutEffect`. Он блокирует отрисовку

**Триггеры рендера** (Что запускает процесс)
- Изменение локального состояния (`useState`, `useReducer`)
- Обновление контекста (`Context API`), на который подписан компонент ([[]])
- Рендер родительского компонента (по умолчанию вызывает рендер всех дочерних компонентов)
  _Важно:_ Изменение пропсов само по себе является следствием рендера родителя


**Особенность React.StrictMode** (Development Only)
- В режиме разработки React намеренно вызывает рендер и эффекты **дважды** (Mount → Unmount → Mount), чтобы помочь разработчику найти неправильную работу с очисткой эффектов. В Production сборке это поведение отключается.


**Архитектурный запрет** (Component Definition):
- *Правило*: Никогда не объявляй компонент внутри тела другого компонента.

- *Причина*: При каждом рендере родителя, вложенный компонент будет создаваться как новая функция. Это приводит к полному уничтожению и пересозданию его DOM-дерева и потере его внутреннего стейта (и фокуса в инпутах). Компоненты всегда должны быть объявлены на верхнем уровне модуля.