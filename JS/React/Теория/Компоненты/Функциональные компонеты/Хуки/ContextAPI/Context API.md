**React Context API** — это встроенный в React механизм для передачи данных через дерево компонентов без необходимости передавать пропсы (`props`) вручную на каждом промежуточном уровне.

Фактически, это способ реализации паттерна _Dependency Injection_ (внедрение зависимостей) внутри компонентной архитектуры React.

#### Основная задача
Решение проблемы **Prop Drilling** (прокидывание пропсов) — ситуации, когда данные нужно передать от родительского компонента к глубоко вложенному дочернему через множество промежуточных компонентов, которые эти данные не используют.

#### Ключевые составляющие
1. **React.createContext**
   Создает объект контекста. При создании можно передать _значение по умолчанию_, которое будет использовано компонентами, если они не обернуты в соответствующий Провайдер

2. **Context.Provider**
   Компонент, который позволяет потребляющим компонентам (consumers) "подписаться" на изменения контекста
   Принимает пропс `value`, который содержит передаваемые данные
   
   При изменении `value` все вложенные компоненты, использующие этот контекст, будут перерендерены

3. **useContext (Hook)**
   Хук, который принимает объект контекста (результат вызова `createContext`) и возвращает текущее значение контекста из ближайшего вышестоящего `Provider`


#### Пример реализации
```JavaScript
import React, { createContext, useContext, useState } from 'react';

// 1. Создание контекста с дефолтным значением
const ThemeContext = createContext('light');

function App() {
  const [theme, setTheme] = useState('dark');

  // 2. Оборачивание дерева в Provider
  // Все дочерние компоненты получат доступ к 'theme'
  return (
    <ThemeContext.Provider value={theme}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// Промежуточный компонент (не принимает пропсов темы)
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  // 3. Получение значения через хук
  // Читает значение 'dark' из ближайшего Provider
  const theme = useContext(ThemeContext);
  
  return <button className={theme}>I am styled with {theme} theme</button>;
}
```

#### Когда использовать
- Глобальное управление состоянием UI (темы, язык интерфейса)
- Данные аутентификации пользователя (текущий юзер, статус входа)
- Кэш данных, используемых во многих частях приложения

#### Когда НЕ использовать
- Только для того, чтобы избежать передачи пропсов на 1-2 уровня вниз (это усложняет переиспользование компонентов)

- Для часто обновляемых данных без должной оптимизации (каждое изменение в `Provider` вызывает ререндер всех потребителей, что может просадить производительность правильной оптимизации)