**Context API** — это встроенный инструмент React для передачи данных через дерево компонентов без необходимости вручную пробрасывать пропсы на каждом уровне (решение проблемы _Prop Drilling_)


### Базовая концепция
Для работы контекста необходимы три элемента:
1. **Context Object (Канал связи)**
    Создается с помощью `React.createContext`. Хранит структуру данных

2. **Provider (Поставщик)**
    Компонент, который "обнимает" часть приложения и предоставляет ей данные. Именно здесь живет _реактивность_

3. **Consumer (Потребитель)**
    Любой компонент, который подписывается на изменения контекста (обычно через хук `useContext`)


### Правильная Архитектура
Профессиональный подход подразумевает вынос всей логики аутентификации или глобального состояния в отдельный модуль. Мы не пишем логику в `App.jsx` и не создаем "голые" объекты в JS-файлах

**Ключевые принципы**
- **Изоляция в отдельный файл**
    Контекст создается в файле (например, `store/AuthContext.js`). Это позволяет импортировать его в любой части приложения

- **Паттерн Custom Provider**
    Мы создаем специальный компонент-обертку (`AuthContextProvider`), который инкапсулирует работу с состоянием (`useState`/`useReducer`) и побочными эффектами (`localStorage`)

- **Паттерн Custom Hook**
    Мы создаем хук (`useAuth`), чтобы скрыть `useContext` от компонентов. Это упрощает код и позволяет добавить валидацию


### Значения по умолчанию
В `createContext` всегда следует передавать объект-заглушку, повторяющий структуру реальных данных

**Зачем это нужно**
- **Автодополнение IDE**
   Редактор кода сможет подсказывать поля (`.isLoggedIn`) и методы (`.onLogout`), так как он знает "форму" объекта

- **Безопасность**
   Если компонент будет случайно отрисован без Провайдера (например, в unit-тесте), вызов методов не приведет к ошибке _undefined is not a function_


### Оптимизация производительности
Любое изменение в пропе `value` у Провайдера вызывает перерисовку **всех** компонентов-потребителей

**Проблема**
Если мы передаем объект `{ isLoggedIn: ..., onLogin: ... }` прямо в `value`, то при каждом ререндере родителя этот объект пересоздается заново (меняется ссылка в памяти). Это провоцирует лишние ререндеры вложенных компонентов

**Решение**
Оборачивать передаваемый объект в `useMemo`. Он сохраняет объект между рендерами, пока не изменятся зависимости (например, сам статус `isLoggedIn`), [[Оптимизация избыточного рендеринга при использовании Context|подробнее тут]]


### Когда использовать Context API
**Глобальные данные**
Тема оформления (Light/Dark), локализация (язык), данные текущего пользователя
  
**Редко изменяемые данные**
Контекст отлично подходит для данных, которые не обновляются каждую секунду

**Важное ограничение**
Не стоит использовать Context для высокочастотных обновлений (например, каждое нажатие клавиши в поле ввода), так как это вызовет _перерисовку всего дерева компонентов_, подписанных на контекст. Для таких задач лучше подходят локальный стейт или специализированные библиотеки (Redux, Zustand)