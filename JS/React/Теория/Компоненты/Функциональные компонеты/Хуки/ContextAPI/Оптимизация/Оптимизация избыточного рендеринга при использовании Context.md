Хотя сам факт вызова useContext заставит компонент-функцию выполниться заново, мы можем предотвратить построение Virtual DOM и рендер дочерних элементов

Поскольку в React Context (в отличие от Redux) нет встроенных селекторов, компонент рендерится даже если обновилось поле, которое ему не нужно

Вот три стратегии борьбы с этим:

#### Стратегия А: Мемоизация возвращаемого значения (Internal useMemo)
Мы не можем запретить компоненту _запуститься_, но мы можем запретить ему _отдавать новый результат_, если нужные нам данные не изменились.

**Сценарий**
В контексте лежит `{ theme, user }`. Компоненту нужен только `user`. Если меняется `theme`, компонент перезапустится.

**Решение**
Обернуть всё возвращаемое дерево JSX в `useMemo`.
```JavaScript
import React, { useContext, useMemo } from 'react';
import AppContext from './AppContext';

export default function UserProfile() {
  // 1. Мы подписываемся на ВЕСЬ контекст. 
  // Если изменится theme, эта строчка выполнится, и компонент UserProfile перезапустится.
  const { user, theme } = useContext(AppContext);

  // 2. Но мы блокируем обновление DOM с помощью useMemo.
  // React выполнит функцию UserProfile, дойдет до useMemo, 
  // сравнит зависимости [user] и, если user не изменился, вернет старый результат рендера.
  return useMemo(() => (
    <div className="profile">
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      {/* Здесь может быть тяжелое поддерево */}
    </div>
  ), [user]); 
}
```

#### Стратегия Б: Компонент-разделитель (Split Component)
Это более чистый архитектурный подход

Мы разделяем компонент на две части:
1. "Глупый" компонент, обернутый в `React.memo`, который принимает данные только через пропсы.
2. Компонент-обертка, который достает данные из контекста и передает их "глупому"

```JavaScript
import React, { useContext, memo } from 'react';
import AppContext from './AppContext';

// 1. Этот компонент защищен React.memo.
// Он перерендерится ТОЛЬКО если изменится проп `user`.
const UserView = memo(({ user }) => {
  console.log('UserView render'); // Сработает только при смене user
  return (
    <div className="profile">
      <h1>{user.name}</h1>
    </div>
  );
});

// 2. Этот компонент всё равно будет "мигать" при каждом обновлении контекста (даже theme).
export default function UserProfileContainer() {
  const { user } = useContext(AppContext);

  // Но рендер остановится здесь, так как React.memo(UserView) увидит, 
  // что ссылка на объект user не изменилась.
  return <UserView user={user} />;
}
```

#### Стратегия В: Сторонние библиотеки (Context Selectors)

В экосистеме React существует проблема, известная как "Context Selector issue"
Команда React работает над нативным хуком `useContextSelector`, но он пока доступен только в экспериментальных сборках или через сторонние библиотеки

Если производительность критична, используют библиотеку `use-context-selector` (её автор Daishi Kato)
```JavaScript
import { createContext, useContextSelector } from 'use-context-selector';

const context = createContext(null);

const Component = () => {
  // Компонент перерендерится ТОЛЬКО если изменится user.name
  // Изменения других полей контекста будут проигнорированы на уровне движка
  const name = useContextSelector(context, v => v.user.name);
  
  return <div>{name}</div>;
};
```

### Итог
Оптимизация на стороне клиента (Consumer) сводится к тому, чтобы остановить волну рендеринга сразу после получения данных из контекста, если эти конкретные данные не изменились.

**Лучший выбор:**
- Если компонент маленький: не оптимизировать (React быстрый)
- Если компонент средний/большой: **Стратегия Б** (разделение на контейнер и отображение)
- Если компонент очень тяжелый или вызывается 1000 раз (список): **Стратегия А** (`useMemo` внутри) или [[Разделение контекста]]