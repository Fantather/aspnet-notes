#### Механизм обновления (Strict Equality Check)
React проверяет изменение значения пропса value у Context.Provider
Сравнение происходит по принципу ссылочного равенства (Object.is или `===`)
- Если ссылка на объект `value` изменилась — **ВСЕ** компоненты, использующие `useContext(MyContext)`, будут принудительно перерисованы
- Важно: React не проверяет, изменилось ли конкретное поле внутри объекта. Если изменилась ссылка на сам объект — рендер неизбежен

#### Игнорирование блокировок (Bypassing optimizations)
Это фундаментальное поведение React Reconciliation, при котором обновление контекста имеет приоритет над механизмами прерывания рендера.

**Природа зависимости**
  Context не является _пропcом_ или _состоянием_ родителя, это _прямая подписка_ на изменения провайдера
  Когда `Provider` обновляется, React помечает все компоненты-потребители как «грязные» (dirty) напрямую, минуя проверку пропсов в родительских компонентах

**Поведение React.memo и PureComponent**
  `React.memo` реализует проверку `prevProps === nextProps`
  
  Поскольку значение контекста не передается через пропсы, эта проверка возвращает `true` (пропсы не изменились), но React _игнорирует_ этот результат для самого компонента, так как видит флаг обновления от контекста
  
  _Важно:_ `React.memo` всё ещё полезен — он предотвратит рендер, если обновился родитель, но _не_ обновился контекст. Но от обновления контекста он не защитит

**Локальность обновления**
  Если компонент подписан на контекст через `useContext`, он _гарантированно_ выполнит функцию рендера (перезапуск тела функции компонента). Однако, если этот компонент возвращает дочерние элементы, обернутые в `React.memo`, и они не зависят от контекста — рендер _остановится_ на них
  
  Волна обновлений начинается в компоненте с `useContext` и идет вниз, пока не встретит следующую границу мемоизации
  

#### Проблема избыточного рендеринга (Over-rendering)
В Context API нет встроенного механизма «селекторов» (в отличие от Redux или Zustand)
- **Сценарий**
  В контексте лежит объект `{ user, theme }`
  
- **Проблема**
  Если обновилась `theme`, компонент, который использует только `user`, *всё равно перерендерится*, потому что он подписан на весь контекст целиком
  
- **Решение**
  [[Оптимизация избыточного рендеринга при использовании Context|Три варианта решения тут]]
  
#### Ловушка ссылочной целостности (The Reference Trap)
Самая частая ошибка, убивающая производительность
  
Если ты передаешь в value новый объект при каждом рендере родителя, ты заставляешь всех потребителей рендериться каждый раз

**Плохо** (создание объекта on-the-fly)
``` js
// При каждом рендере App создается НОВЫЙ объект {}, ссылка меняется
<Context.Provider value={{ user, logout }}>
```  

**Хорошо** (стабилизация ссылки)
``` js
// Объект пересоздается только если изменился user или logout
const contextValue = useMemo(() => ({ user, logout }), [user, logout]);

<Context.Provider value={contextValue}>
```

[[Пример оптимизации через useMemo||Более развёрнутый пример оптимизации через useMemo]]

### Итог
**Тотальное обновление**
  При изменении `value` в Провайдере, рендерятся **все** потребители (`useContext`) вниз по дереву

**Пробивание Memo**
  Обновление контекста игнорирует `React.memo`. Если контекст изменился, компонент перерисуется, даже если его пропсы не менялись

**Отсутствие селекторов**
  Компонент получает уведомление об изменении всего объекта значения. Если в контексте 10 полей, а поменялось 1, компонент, использующий остальные 9, тоже перерендерится

**Важность useMemo**
  Значение, передаваемое в `Provider`, должно быть мемоизировано (`useMemo`), чтобы избежать случайных обновлений всех потребителей при рендере родительского компонента