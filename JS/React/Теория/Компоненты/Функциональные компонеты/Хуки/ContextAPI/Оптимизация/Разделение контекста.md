Это одна из самых профессиональных оптимизаций в React (паттерн **Split Context**)

**Суть проблемы, которую мы решаем**
Часто компоненту нужна только *функция* для изменения состояния, но ему не нужны сами *данные*
Если всё лежит в одном контексте, кнопка будет перерисовываться каждый раз, когда меняются данные

Вот как архитектурно правильно разделить контексты

### Паттерн: Разделение State и Actions (Dispatch)
Вместо одного `ModalContext`, мы создаем два:
1. `ModalValueContext` — хранит только *данные* (открыто/закрыто, контент)
2. `ModalActionsContext` — хранит только *функции* (open, close)


#### 1. Реализация (код для понимания)
```JavaScript
import { createContext, useContext, useState, useMemo, useCallback } from 'react';

// 1. Создаем два отдельных контекста
const ModalValueContext = createContext(null);
const ModalActionsContext = createContext(null);

export const ModalProvider = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [content, setContent] = useState(null);

  // 2. Группируем данные (меняются часто)
  const valueState = useMemo(() => ({ isOpen, content }), [isOpen, content]);

  // 3. Группируем функции (стабильны, не меняются при рендере)
  const actions = useMemo(() => ({
    open: (newContent) => {
      setContent(newContent);
      setIsOpen(true);
    },
    close: () => setIsOpen(false),
  }), []); // Пустой массив зависимостей = ссылка вечная

  return (
    <ModalActionsContext.Provider value={actions}>
      <ModalValueContext.Provider value={valueState}>
        {children}
      </ModalValueContext.Provider>
    </ModalActionsContext.Provider>
  );
};

// 4. Хуки для удобного использования
export const useModalValue = () => useContext(ModalValueContext);
export const useModalActions = () => useContext(ModalActionsContext);
```


#### 2. Почему это работает (Архитектурный эффект)
Представь себе компонент `<Header />`, в котором есть кнопка «Войти».
- Кнопка вызывает `const { open } = useModalActions();`
- Когда модалка открывается, обновляется `isOpen` (в `ModalValueContext`)
  
- **Результат:** Компонент `<Header />` **НЕ перерендерится**, потому что он подписан только на `ActionsContext`, а ссылка на объект `actions` не изменилась
  Перерендерится только сама `<ModalWindow />`, которая подписана на `ValueContext`