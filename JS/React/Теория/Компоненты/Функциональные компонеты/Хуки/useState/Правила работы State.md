В экосистеме React не существует единственного официального закона, называемого «правилом большого пальца» (rule of thumb). Однако, в профессиональном сообществе и документации этим термином чаще всего обозначают **алгоритм определения места расположения состояния (State)**.

Это правило часто формулируется так: **«Состояние должно находиться в ближайшем общем предке компонентов, которым нужны эти данные»**.

Ниже подробно описан этот и другие ключевые принципы (эвристики), позволяющие писать чистый и поддерживаемый код.

---

### 1. Правило расположения состояния (Lifting State Up)

В React данные передаются **однонаправленно** (сверху вниз, от родителя к потомку). Компоненты-сиблинги (соседи) не могут обмениваться данными напрямую.

**Правило:** Если два или более компонента нуждаются в одних и тех же данных, вы не должны дублировать состояние в каждом из них. Вместо этого вы должны найти их **ближайшего общего родителя** и переместить (поднять) состояние туда.

#### Алгоритм поиска места для `useState` (или `this.state`):

1. Определите каждый компонент, который использует эти данные для рендеринга.
    
2. Найдите их ближайшего общего родителя (компонент, который находится выше всех перечисленных в иерархии).
    
3. Разместите состояние в этом общем родителе.
    
4. Передавайте данные вниз через `props`.
    

Пример:

У вас есть список товаров (ProductList) и компонент, отображающий общее количество товаров (TotalCount).

- **Неверно:** Хранить массив товаров внутри `ProductList` и пытаться передать его в `TotalCount` (это невозможно, так как они соседи).
    
- **Верно:** Хранить массив товаров в их общем родителе (например, `App` или `ShopPage`), и передавать его как пропсы в оба компонента.
    

---

### 2. Правило «Вычисляемого значения» (Derived State)

Второе важное правило касается избыточности данных.

Правило: Если значение можно вычислить на основе props или уже существующего state, оно не должно находиться в стейте.

Хранение избыточных данных приводит к багам рассинхронизации, когда одно значение обновилось, а зависимое от него — нет.

#### Техническая реализация:

Вместо создания новой переменной состояния (`useState`), вычисляйте значение прямо в теле функционального компонента (во время рендеринга) или используйте хук `useMemo` для оптимизации.

**Анти-паттерн (Неверно):**

JavaScript

```
const [firstName, setFirstName] = useState('Ivan');
const [lastName, setLastName] = useState('Ivanov');
// ОШИБКА: fullName зависит от двух других, его не надо хранить в стейте
const [fullName, setFullName] = useState('Ivan Ivanov');

const changeName = (newFirst) => {
  setFirstName(newFirst);
  setFullName(`${newFirst} ${lastName}`); // Приходится обновлять вручную
};
```

**Правильный подход:**

JavaScript

```
const [firstName, setFirstName] = useState('Ivan');
const [lastName, setLastName] = useState('Ivanov');

// Значение вычисляется автоматически при каждом рендере
const fullName = `${firstName} ${lastName}`; 
```

---

### 3. Правило единственной ответственности (Single Responsibility Principle)

Это правило применимо к архитектуре компонентов.

Правило: Компонент должен в идеале делать только одну вещь. Если компонент разрастается, его следует разбить на более мелкие подкомпоненты.

Как понять, что правило нарушено:

- Компонент содержит сложную логику обработки данных **и** сложную верстку.
    
- В компоненте слишком много `useEffect` с разной логикой.
    
- Компонент принимает слишком много `props`, которые не связаны друг с другом логически.
    

Это часто приводит к разделению на:

- **Container Components (Smart):** Отвечают за логику, загрузку данных, управление состоянием.
    
- **Presentational Components (Dumb):** Отвечают только за визуализацию (UI) и получают данные через `props`.
    

---

### 4. Правило иммутабельности (Immutability)

Это фундаментальный принцип работы React, который можно считать жестким правилом.

Правило: Никогда не изменяйте (мутируйте) состояние напрямую. Всегда создавайте копию данных с изменениями.

React сравнивает ссылки на объекты, чтобы понять, нужно ли перерисовывать интерфейс (Reconciliation). Если вы измените поле объекта без создания новой ссылки, React может не заметить изменений и не обновить DOM.

**Пример с массивом:**

JavaScript

```
const [items, setItems] = useState(['A', 'B']);

// НЕВЕРНО (Мутация):
items.push('C'); 
setItems(items); // Ссылка на массив та же самая, React может проигнорировать обновление

// ВЕРНО (Создание копии):
setItems([...items, 'C']); // Создается новый массив
```

### Сводная таблица подходов

|**Ситуация**|**Решение (Правило большого пальца)**|
|---|---|
|Данные нужны нескольким компонентам|**Поднимайте состояние (Lift State Up)** к общему предку.|
|Значение можно получить из `props`|**Не создавайте стейт**, вычисляйте значение при рендере.|
|Компонент стал слишком большим|**Декомпозируйте** его на меньшие компоненты.|
|Нужно изменить объект/массив в стейте|**Используйте копирование** (spread-оператор, map, filter), не мутируйте оригинал.|

Хотели бы вы рассмотреть пример кода, где мы проводим рефакторинг компонента, нарушающего правило «Lifting State Up»?