# Конспект: useMemo

## 1. Определение

useMemo — это хук, который кеширует результат выполнения функции между рендерами.

В отличие от useCallback (который запоминает саму функцию), useMemo запоминает возвращаемое значение (число, строку, объект, массив).

## 2. Зачем использовать?

Существует ровно две причины для применения этого хука:

1. **Оптимизация производительности (Heavy Computation):** Чтобы не выполнять "дорогие" вычисления (сложные фильтрации, сортировки, математику) при каждом рендере, если исходные данные не изменились.
    
2. **Ссылочная целостность (Referential Equality):** Чтобы сохранить ссылку на объект или массив неизменной. Это нужно, если этот объект передается в качестве пропса в компонент, обернутый в `React.memo`, или используется в массиве зависимостей другого хука (`useEffect`).
    

## 3. Синтаксис

```JavaScript
const cachedValue = useMemo(calculateValue, dependencies);
```

- **`calculateValue`**: Функция, которая возвращает значение, которое нужно закешировать. Она должна быть чистой (pure), не принимать аргументов и обязательно возвращать результат.
    
- **`dependencies`**: Массив зависимостей. Все реактивные значения (props, state, переменные внутри компонента), используемые внутри функции вычисления.
    

## 4. Алгоритм работы

1. **Первый рендер:** React вызывает `calculateValue`, запоминает результат в памяти и возвращает его.
    
2. **Следующие рендеры:**
    
    - React сравнивает текущие зависимости с зависимостями из предыдущего рендера (поверхностное сравнение `Object.is`).
        
    - **Если зависимости не изменились:** React **не вызывает** функцию. Он возвращает сохраненный результат из памяти.
        
    - **Если хотя бы одна зависимость изменилась:** React снова вызывает `calculateValue`, сохраняет новый результат и возвращает его.
        

---

## 5. Примеры использования (Patterns)

### Сценарий А: Тяжелые вычисления (Фильтрация списка)

Без `useMemo` метод `.filter()` запускался бы при каждом рендере (даже если вы просто мигаете курсором в инпуте), создавая новый массив.

```JavaScript
import { useMemo, useState } from 'react';

export default function TodoList({ todoList }) {
    const [filter, setFilter] = useState('active'); 

    // filterTodos - это РЕЗУЛЬТАТ (массив), а не функция
    const visibleTodos = useMemo(() => {
        // Эта логика выполнится, только если изменится список или тип фильтра
        console.log("Filtering tasks..."); 
        
        switch (filter) {
            case 'active':
                return todoList.filter(task => !task.isDone);
            case 'completed':
                return todoList.filter(task => task.isDone);
            default:
                return todoList;
        }
    }, [todoList, filter]); // <-- Зависимости

    return (
        <ul>
            {/* Мы рендерим уже мемоизированный массив */}
            {visibleTodos.map(task => <Task key={task.id} task={task} />)}
        </ul>
    );
}
```

### Сценарий Б: Сохранение ссылок для объектов

Если вы создаете объект внутри компонента и передаете его в дочерний `memo`-компонент, без `useMemo` оптимизация сломается (так как `{...} !== {...}`).

```JavaScript
export default function TodoStats({ todoList }) {
    
    // Создаем объект статистики
    // Без useMemo этот объект был бы новым при каждом рендере
    const stats = useMemo(() => {
        return {
            total: todoList.length,
            completed: todoList.filter(t => t.isDone).length
        };
    }, [todoList]);

    return (
        // ChartComponent обернут в React.memo
        // Благодаря useMemo, пропс "data" не меняет ссылку, и рендера не будет
        <ChartComponent data={stats} />
    );
}
```

---

## 6. Чек-лист: Нужно ли здесь useMemo?

1. Вычисляется ли значение на основе `props` или `state`?
    
2. Является ли вычисление сложным (циклы по тысячам элементов)? **ИЛИ** Является ли результат объектом/массивом, который передается в `React.memo` компонент?
    
3. Если ответы "Да" — используем `useMemo`.
    
4. Если это простая конкатенация строк или легкая арифметика — `useMemo` не нужен (накладные расходы на его создание будут выше пользы).


Есть ли у вас сейчас в `TodoList` функционал (например, фильтрация или статистика), где вы хотели бы применить это на практике?