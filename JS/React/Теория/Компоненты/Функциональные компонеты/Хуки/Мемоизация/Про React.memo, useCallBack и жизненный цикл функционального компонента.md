## 1. Фундамент: Жизненный цикл функционального компонента

Чтобы понять оптимизацию, нужно помнить, как работает функциональный компонент.

- **Компонент — это функция.** Рендер — это **вызов** этой функции.
    
- **Изоляция области видимости (Scope):** При каждом рендере (вызове функции) внутри создается новая область видимости.
    
- **Переменные и функции:** Любые константы, переменные и функции, объявленные внутри компонента (`const handleClick = () => ...`), создаются **заново** при каждом вызове. В памяти компьютера выделяется новое место под новый объект функции.
    

### Ссылочное сравнение (Referential Equality)

В JavaScript сравнение объектов (и функций) происходит по ссылке на ячейку памяти, а не по содержимому.



```JavaScript
// Рендер 1
const func1 = () => {};
// Рендер 2
const func2 = () => {};

console.log(func1 === func2); // false (Разные ссылки в памяти)
```

Для React это означает, что даже если код функции идентичен, технически это **новая** функция.

---

## 2. Стабильность Хуков (Identity Stability)

Вы спросили: _"Это же не только setState себя так ведёт?"_

**Ответ:** Да, React гарантирует стабильность ссылок для ряда встроенных механизмов. Это сделано специально, чтобы не провоцировать лишние эффекты и рендеры.

**Что гарантированно имеет стабильную ссылку (не меняется между рендерами):**

1. **Функция обновления состояния:** `setState` из `useState`.
    
2. **Функция dispatch:** из `useReducer`.
    
3. **Объект ref:** Возвращаемое значение `useRef` (сам объект `{ current: ... }`).
    

**Что НЕ стабильно (пересоздается каждый рендер):**

1. Любые функции, которые вы объявляете сами внутри тела компонента.
    
2. Результаты вычислений (обычные переменные, объекты, массивы), если они не обернуты в `useMemo`.
    

---

## 3. Инструмент №1: React.memo

`React.memo` — это компонент высшего порядка (HOC - Higher Order Component), предназначенный для предотвращения лишних рендеров **дочернего компонента**.

- **Принцип работы:** Он "мемоизирует" (запоминает) результат рендера компонента. Перед следующим рендером он проводит **поверхностное сравнение (Shallow Comparison)** новых пропсов с предыдущими.
    
- **Алгоритм:**
    
    - Если пропсы примитивы (`string`, `number`, `boolean`) и их значения равны — рендера не будет.
        
    - Если пропсы объекты/массивы/функции — он сравнивает их ссылки.
        
- **Проблема:** Если родитель перерисовался, он пересоздал функции-обработчики. Ссылки изменились. `React.memo` видит, что пропсы "разные", и всё равно запускает рендер.
    

---

## 4. Инструмент №2: useCallback

`useCallback` — это хук, созданный специально для решения проблемы нестабильных ссылок на функции.

- **Что делает:** Он возвращает мемоизированную версию функции (сохраняет ссылку на один и тот же экземпляр функции между рендерами).
    
- **Когда обновляется:** Ссылка на функцию изменится **только тогда**, когда изменится одна из зависимостей, переданных в массиве (второй аргумент).
    

### Связка `useCallback` + `Замыкания` (Closures)

Функции в JS "замыкают" (запоминают) переменные из своей области видимости.

- Если массив зависимостей пуст `[]`: `useCallback` вернет функцию, созданную при первом рендере. Она "помнит" состояние (`state`, `props`) только первого рендера. Это может привести к багам (Stale Closures).
    
- Если зависимости указаны `[value]`: При изменении `value` React создаст новую функцию, которая "замкнет" новое актуальное значение.
    

---

## Итоговая цепочка оптимизации

1. У вас есть тяжелый дочерний компонент или список элементов.
    
2. Вы оборачиваете дочерний компонент в `React.memo`, чтобы он не перерисовывался без нужды.
    
3. Но вы передаете ему пропсом функцию (`onClick`, `onDelete`).
    
4. Чтобы не ломать `React.memo` (из-за смены ссылок на функцию), вы оборачиваете эту функцию в родителе в `useCallback`.
    

---

# Примеры синтаксиса

### 1. Синтаксис `React.memo`

Чаще всего используется прямо при экспорте компонента.


```JavaScript
import React from 'react';

function Task({ task, onDoneChange }) {
    console.log("Task Rendered"); // Сработает только если изменятся task или onDoneChange
    return (
        <li>{task.text}</li>
    );
}

// Оборачиваем компонент при экспорте
// Теперь Task будет рендериться, только если пропсы реально изменились (поверхностно)
export default React.memo(Task);
```

### 2. Синтаксис `useCallback`

Используется внутри функционального компонента или кастомного хука.

```JavaScript
import { useState, useCallback } from 'react';

export default function useTodoList() {
    const [todoList, setTodoList] = useLocalStorage([]);
    const [categoryId, setCategoryId] = useState(1);

    // ВАРИАНТ 1: Без зависимостей от внешних переменных (кроме setState)
    // Эта функция будет иметь одну и ту же ссылку весь жизненный цикл компонента.
    const deleteTask = useCallback((id) => {
        setTodoList(prev => prev.filter(task => task.id !== id));
    }, [setTodoList]); // setTodoList стабильна, можно даже опустить, но линтер попросит

    
    // ВАРИАНТ 2: С зависимостью
    // Ссылка на эту функцию будет меняться каждый раз, когда меняется categoryId
    const addTaskToCategory = useCallback((text) => {
        const newTask = { text, category: categoryId }; // Используем значение из замыкания
        setTodoList(prev => [...prev, newTask]);
    }, [categoryId, setTodoList]); // ОБЯЗАТЕЛЬНО указываем categoryId

    return { todoList, deleteTask, addTaskToCategory };
}
```

### 3. Комплексный пример (Связка)

```JavaScript
// Родитель (использует хук с useCallback)
function TodoApp() {
    // deleteTask - это стабильная функция благодаря useCallback внутри хука
    const { todoList, deleteTask } = useTodoList(); 

    return (
        <ul>
            {todoList.map(task => (
                <Task 
                    key={task.id} 
                    task={task} 
                    // Мы передаем стабильную ссылку.
                    // React.memo внутри Task скажет: "Функция та же, данные те же -> рендер не нужен".
                    onDelete={deleteTask} 
                />
            ))}
        </ul>
    );
}
```