## Описание
`useQuery` — это хук для управления *асинхронным состоянием* (server state) в React-приложениях. Он занимается загрузкой, кэшированием, синхронизацией и обновлением данных, полученных от сервера

В 5-й версии библиотеки используется строго объектный синтаксис аргументов

## Установка и настройка
Библиотека не входит в стандартный React, её нужно установить и подключить провайдер контекста

Выполни команду в терминале:
```bash
npm i @tanstack/react-query
```


Для работы хуков всё приложение (или ту часть, где используется Query) нужно обернуть в `QueryClientProvider`. Он отвечает за управление _кэшем_ и передачу настроек
``` JavaScript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// 1. Создаем экземпляр клиента (хранилище кэша)
const queryClient = new QueryClient();

function App() {
  return (
    // 2. Оборачиваем приложение в провайдер
    <QueryClientProvider client={queryClient}>
      <YourApplication />
    </QueryClientProvider>
  );
}
```


## Основные параметры (Options)
Принимает объект с настройками:

**queryKey**
  Обязательный массив, уникально идентифицирующий запрос. Любое изменение ключа вызывает автоматический перезапрос (refetch). Ключи должны быть сериализуемыми

**queryFn**
  Асинхронная функция, возвращающая промис. Должна либо вернуть данные, либо выбросить ошибку

**staleTime**
  Время в миллисекундах, в течение которого данные считаются *свежими*
  Пока данные свежие, повторные монтирования компонента не вызывают сетевой запрос (по умолчанию `0`)

**gcTime**
  Бывший `cacheTime`. Время, которое неиспользуемые данные хранятся в кэше перед удалением сборщиком мусора (по умолчанию 5 минут)

**enabled**
  Булево значение. Если `false`, запрос не выполняется автоматически. Используется для зависимых запросов

**select**
  Функция для трансформации или селекции части полученных данных. Позволяет избежать лишних ререндеров, если возвращаемое значение стабильно

**retry**
  Количество попыток повторного запроса при ошибке (по умолчанию `3`)

### Возвращаемые значения
**data**
  Успешно полученные данные (или `undefined`, если данных нет)

**error**
  Объект ошибки, если запрос завершился неудачей

**isPending**
  `true`, если данные отсутствуют и запрос выполняется впервые. Заменил `isLoading` в v5 для семантической точности

**isLoading**
  В v5 это синоним `isPending && !isPaused`. Обычно лучше использовать `isPending`

**isFetching**
  `true` в любой момент, когда выполняется сетевой запрос (включая фоновые обновления)

**refetch**
  Функция для ручного вызова обновления данных

## Базовый пример
```jsx
import { useQuery } from '@tanstack/react-query';
import { fetchTodos } from './api';

const TodoList = () => {
	const { data, isPending, error } = useQuery({
		queryKey: ['todos'],
		queryFn: fetchTodos,
		staleTime: 1000 * 60 * 5 // 5 минут
	});
	
	if (isPending) return <span>Загрузка...</span>;
	if (error) return <span>Ошибка: {error.message}</span>;
	
	return (
		<ul>
			{data.map(todo => <li key={todo.id}>{todo.title}</li>)}
		</ul>
	);
};
```

### Разбор работы кода

В данном примере происходит декларативное описание зависимости компонента от данных:

**Инициализация и кэширование**
  Хук `useQuery` региструет запрос с ключом `['todos']`
  
  Если данные для этого ключа уже есть в кэше и они _свежие_ (не прошло 5 минут, заданные в `staleTime`), хук вернет их мгновенно без сетевого запроса. Если данных нет или они устарели, сработает `queryFn` (`fetchTodos`)

**Управление потоком данных (Early Return)**
  Используется паттерн раннего возврата для обработки промежуточных состояний
  Сначала проверяется `isPending` — это гарантирует, что мы не попытаемся обратиться к `data`, пока они не загружены. Затем проверяется `error`, чтобы безопасно обработать исключения API

**Безопасный рендеринг**
  До момента выполнения `return <ul>...` код доходит только в том случае, если `isPending` ложно и `error` отсутствует. Это гарантирует, что переменная `data` определена и содержит массив, что позволяет безопасно вызвать метод `.map()` для отрисовки списка