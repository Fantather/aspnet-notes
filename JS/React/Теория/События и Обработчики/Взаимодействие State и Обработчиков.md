### Плохой вариант
Представим что я попытался написать обработчик `onChange` для тега *Input*, который будет записывать вводимое пользователем в *state*-переменную
```JSX
handleChange = (event) =>{
	this.setState(() => {
		text: event.target.value
	})
}
```
Основная проблема в том что `setState` это асинхронная функция, мы передаём в неё другую функцию, а `event` это ссылка на внешний объект

Что бы понять проблему, нужно понять Как будет выполняться код и какие уязвимости он в себе несёт
1. Интерпретатор заходит в обработчик
2. Видит асинхронный `setState` и считывает то что мы передаём в него функцию
3. Передаёт в *Внутреннюю очередь обновлений React* (*Fiber*) метод `setState` с аргументом в виде Функции, то есть c Инструкцией о том, как получить аргументы для `setState`, но не сами аргументы
4. Из *Fiber* в *Call Stack*  метод `setState` расположится После выполнения всего синхронного кода в `handleChange`, то есть Начнёт выполнение после того, как обработчик завершится
5. Интерпретатор дальше выполняет обработчик, пока тот не закончится
6. И только сейчас из *Call Stack* будет вызван метод `setState` и начнёт выполняться переданная функция для получения аргументов

До версии React 17 объект `event` был один на весь код и когда обработчик заканчивал свою работу `event` присваивал всем своим свойствам `null`, этот механизм называется *Event Pooling*
Так что функция `setState` вместо `event` обнаруживала бы `null`

С React 17 *Event Pooling* убрали и `event` перестал быть один на весь проект
Теперь, когда мы передаём функцию в `setState`, она Захватывает объект `event` и не даёт ему быть собранным *GC*, так что технически такая запись теперь будет работать, потому что *React* стал мягче
Но есть и другие причины, почему это плохой вариант

#### Ссылка на event
Как упоминалось раньше функция переданная в `setState` в качестве аргумента Замыкает все используемые ей объекты
Объект `event` в свою очередь довольно массивный и ссылается уже на `DOM` элементы, то есть этим замыканием мы держим в оперативной памяти огромную структуру данных лишнее время и не даём *GC* его удалить ради одной переменной - это не рациональное использование памяти и в больших приложениях это может снизить производительность

#### Добавление задержки
В примере у нас ввод пользователя и наш *state* обновляется при вводе каждого символа и для оптимизации мы можем реализовать паттерн [[Debounce]], через метод `setTimeout` и 500мс ожидать ввод пользователя, прежде чем сохранить новое значение в *state*

Но полагаться на внешнее значение `event.target` спустя пол секунды - не надёжно, потому что `event.target` это ссылка на мутабельный DOM-элемент и это влечёт за собой неожиданное поведение и трудно обнаружимые исключения

#### Чистая функция
Один из признаков [[Чистая функция|Чистой функции]] то, что она не зависит от внешнего состояния и ничего не меняет вне себя, а `event` это именно что внешний объект, который может менять своё состояние


Так что хорошей практикой будет в начале обработчика сохранять в `const` переменные необходимые значения из `event`

### Лучшие практики
Если нас не волнует предыдущее состояние объекта *state*, то мы пишем такую короткую версию
`event` - Название для переменной, в которую React автоматически передаст объект, который вызвал событие

Тут в `setState` мы передаём объект, потому что завернули написанное в `{}`, поэтому когда `setState` будет вызван из *Call Back*, в его параметрах будет конкретное значение

```jsx
handleChange = (event) =>{
	this.setState({
		text: event.target.value
	})
}
```


Если мы пытаемся передать функцию в `setState`, то мы записываем в константы все мутабельные аргументы для функции, которая будет вызвана в `setState`
```jsx
handleChange = (event) =>{
	const val = event.target.value;
	this.setState((prevState) => {
		console.log(prevState.text);
		return{
			text: val
		}
	})
}
```