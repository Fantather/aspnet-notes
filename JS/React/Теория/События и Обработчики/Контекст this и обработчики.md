Это фундаментальная особенность языка JavaScript, связанная с тем, как определяется контекст выполнения (`Execution Context`).

Короткий ответ: **`this` в JavaScript определяется не тем, где функция была создана, а тем, как она была вызвана.**

Потеря контекста происходит не только в обработчиках событий, а в любой ситуации, где вы передаете метод как **значение** (callback), вместо того чтобы сразу его вызывать.

Давайте разберем это механически, шаг за шагом.

### 1. Метод объекта vs Ссылка на функцию

Когда вы пишете код, есть огромная разница между **вызовом** метода и **передачей** метода.

#### Сценарий А: Вызов метода (Context сохраняется)

JavaScript

```
obj.method();
```

Здесь работает правило "точка". Интерпретатор видит: "Вызвать функцию `method`, которая принадлежит объекту `obj`". В этот момент `this` автоматически устанавливается на `obj`.

#### Сценарий Б: Передача ссылки (Context теряется)

JavaScript

```
const myFunc = obj.method; // Мы не вызываем (), мы просто копируем ссылку на функцию
myFunc(); // Вызов функции без контекста
```

В этой строке мы достали функцию из объекта и положили её в отдельную переменную. Связь с obj была разорвана. Теперь myFunc — это просто "голая" функция.

Когда мы вызываем myFunc(), перед ней нет точки и объекта. Интерпретатор не знает, к кому она относится, и ставит this в значение undefined (в строгом режиме).

### 2. Что происходит внутри React (почему именно обработчики?)

Когда вы пишете в JSX:

JavaScript

```
<button onClick={this.handleDeleteTask}>
```

Вы делаете ровно то же самое, что и в Сценарии Б.

1. Вы берете функцию `handleDeleteTask` из текущего экземпляра (`this`).
    
2. Вы **отдаете** эту функцию React'у. Вы не вызываете её.
    

Внутри React (упрощенно) происходит примерно следующее:

JavaScript

```
// Где-то в недрах React или DOM
// React сохранил вашу функцию в переменную callback
const callback = props.onClick; 

// ... прошло время, пользователь кликнул ...

// React вызывает сохраненную функцию
callback(event); 
```

Обратите внимание: React вызывает `callback(event)`, а не `component.callback(event)`. Вызов происходит "без точки". Связь с классом потеряна, поэтому `this` внутри функции становится `undefined`.

### 3. Почему это `undefined`, а не глобальный объект?

Классы в JavaScript (`class`) по умолчанию работают в **строгом режиме** (`"use strict"`).

- В старом JS (без strict mode) при потере контекста `this` указывал бы на глобальный объект `window`.
    
- В классах (strict mode) `this` при потере контекста становится `undefined`. Именно поэтому вы получаете ошибку `Cannot read properties of undefined`.
    

### 4. Почему стрелочные функции решают это?

Стрелочные функции (=>) игнорируют правило вызова. У них вообще нет своего собственного this.

Когда движок JS встречает this внутри стрелочной функции, он берет его из лексического окружения (того места, где код написан физически).

JavaScript

```
handleDeleteTask = () => {
    // У стрелочной функции нет своего this.
    // Она смотрит наружу: "Где я написана? Внутри класса Component".
    // Значит this — это экземпляр Component.
    console.log(this); 
}
```

### Резюме

1. **Потеря контекста** происходит потому, что в JS методы не привязаны к объектам "намертво". Связь существует только в момент вызова через точку (`obj.method()`).
    
2. **Передача в `onClick`** — это передача ссылки на функцию, а не вызов метода. React сохраняет функцию и вызывает её позже отдельно от объекта.
    
3. **Стрелочные функции** фиксируют `this` в момент создания (лексически), поэтому они невосприимчивы к способу вызова.