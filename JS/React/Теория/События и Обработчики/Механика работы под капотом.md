React не использует нативные события напрямую в компонентах. Вместо этого он реализует собственный слой абстракции для кроссбраузерной совместимости и оптимизации производительности.

### 1. Обертка SyntheticEvent

Когда вы указываете атрибут `onClick` в JSX, в обработчик передается не нативный объект события DOM, а экземпляр класса `SyntheticEvent`.

- **Назначение:** Это кроссбраузерная обертка над нативным событием браузера. Она гарантирует, что свойства события (например, `e.target`, `e.preventDefault()`) работают идентично в Chrome, Firefox, Safari и старых браузерах, исправляя несоответствия стандартов.
    
- **Интерфейс:** Полностью повторяет интерфейс нативного события (W3C spec), включая методы `stopPropagation()` и `preventDefault()`.
    
- **Доступ к оригиналу:** Если нужен доступ к исходному событию браузера, он находится в свойстве `e.nativeEvent`.


```JavaScript
const handleClick = (e) => {
  console.log(e);             // SyntheticBaseEvent (объект React)
  console.log(e.nativeEvent); // PointerEvent (нативный объект браузера)
};
```


### 2. Делегирование событий (Event Delegation)

React использует глобальное делегирование событий. Это ключевой архитектурный момент.

**Как это работает:**

1. **Отсутствие локальных слушателей:** Когда React рендерит DOM-элементы (например, `<button>`), он **не вешает** на них `addEventListener`.
    
2. **Единый слушатель на корне:** Вместо этого React вешает по одному обработчику для каждого типа событий (`click`, `keydown`, `change` и т.д.) на корневой контейнер приложения (тот элемент, куда вы монтируете приложение: `ReactDOM.createRoot(rootElement)`).
    
    - _Примечание:_ До React 17 слушатели вешались на `document`. Начиная с React 17 — на корневой `div` приложения (root container), что позволяет безопаснее запускать несколько React-приложений на одной странице.
        
3. **Перехват и маршрутизация:**
    
    - Когда происходит клик по кнопке, нативное событие всплывает (bubbles) до `rootElement`.
        
    - Обработчик React на `rootElement` перехватывает его.
        
    - React сопоставляет `e.target` (нативный узел) со своим внутренним деревом компонентов (Fiber tree).
        
    - Он находит соответствующий компонент и вызывает переданную вами функцию `onClick`.


### 3. Эмуляция фаз (Bubbling и Capture)

Поскольку React перехватывает событие на самом верху (на контейнере), фазы погружения и всплытия **внутри** дерева React-компонентов эмулируются программно.

1. **Нативное событие всплыло:** Сначала нативное событие проходит весь путь до `root`.
    
2. **Сбор путей:** React определяет цепочку компонентов от `target` вверх до корня.
    
3. **Исполнение Capture:** React проходит по этой цепочке вниз, вызывая обработчики с суффиксом Capture (например, `onClickCapture`).
    
4. **Исполнение Bubbling:** React проходит по этой цепочке вверх, вызывая стандартные обработчики (например, `onClick`).
    

**Пример синтаксиса:**

```JavaScript
<div onClickCapture={handleCapture}> {/* Сработает первым (фаза погружения) */}
  <button onClick={handleBubbling}>  {/* Сработает вторым (фаза всплытия) */}
    Click Me
  </button>
</div>
```


### 4. Ключевые отличия от Native DOM

|**Характеристика**|**Native DOM**|**React**|
|---|---|---|
|**Именование**|`onclick` (lowercase)|`onClick` (camelCase)|
|**Значение**|Строка: `onclick="handler()"`|Функция: `onClick={handler}`|
|**Отмена действия**|`return false` или `e.preventDefault()`|Только `e.preventDefault()`|
|**Асинхронность**|Обработчик выполняется синхронно|В React 17+ события тоже выполняются синхронно, но _обновление стейта_ внутри них батчится (Automatic Batching).|

### 5. `e.currentTarget` в React
В React свойство `e.currentTarget` работает строго по спецификации, но с нюансом реализации.

- В момент выполнения колбэка `e.currentTarget` указывает на тот DOM-элемент, к которому "привязан" (через JSX) данный обработчик.
    
- **Важно:** Из-за того, как React обрабатывал события раньше (Event Pooling — удалено в React 17), разработчики привыкли не сохранять event в асинхронных операциях. В современном React (17/18+) объект события **не очищается** и его можно безопасно логировать или использовать в `setTimeout`, но `currentTarget` будет `null` после завершения всплытия, так как контекст обработки события завершен.
    


### 6. Взаимодействие Native и React событий
Так как React ловит события на корневом элементе, возникает классическая проблема при использовании `e.stopPropagation()`:

Если у вас есть микс нативного кода и React:

1. Клик происходит внутри React-компонента.
    
2. Вы делаете `e.stopPropagation()` в React-обработчике.
    
3. **Результат:** Событие не всплывет выше по иерархии _React-компонентов_.
    
4. **НО:** Нативное событие уже успело всплыть до `document` (если React 17+ смонтирован в `root`), потому что React перехватывает его именно там. Если у вас висит нативный слушатель на `document.addEventListener('click')`, он сработает, даже если в React вы вызвали `stopPropagation`.
    

Для блокировки нативных слушателей выше по дереву DOM часто приходится использовать `e.nativeEvent.stopImmediatePropagation()`