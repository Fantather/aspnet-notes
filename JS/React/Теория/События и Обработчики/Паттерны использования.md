### Передача аргументов
Если обработчику нужно передать данные (например, `id` элемента), нельзя писать `onClick={fn(id)}`, так как это вызовет функцию мгновенно при отрисовке.

Используем стрелочную функцию-обёртку:
```JSX
<button onClick={() => handleDelete(id)}>
  Удалить
</button>
```

### Асинхронность и замыкания
В функциональных компонентах обработчики событий — это просто функции. Они "запоминают" (замыкают) значения переменных (`state` или `props`) **на тот момент, когда компонент отрисовался**.

Если внутри обработчика есть асинхронная операция (например, `setTimeout` или запрос к серверу), то к моменту её выполнения данные в `state` могут уже измениться, но функция будет видеть **старое** значение.

Пример проблемы:

Представь счетчик. Мы нажимаем кнопку, но хотим, чтобы число увеличилось через 3 секунды.

```JavaScript
const [count, setCount] = useState(0);

const handleDelayedClick = () => {
  setTimeout(() => {
    // Проблема: Внутри этой функции count навсегда "застрял" на значении 0 (если это был первый рендер)
    console.log("Внутри timeout:", count); 
    setCount(count + 1); 
  }, 3000);
};
```

Если быстро нажать на кнопку 5 раз:

1. Запустятся 5 таймеров.
    
2. Каждый из них "думает", что `count` равен `0`.
    
3. В итоге через 3 секунды мы получим число `1`, а не `5`.


Передача функций внутрь setState решает эту проблему
```JSX
this.setState(prevState => ({ count: prevState.count + 1 }));
this.setState(prevState => ({ count: prevState.count + 1 }));
this.setState(prevState => ({ count: prevState.count + 1 }));
```

Здесь мы передаём не готовое значение, а **инструкцию**. React ставит эти функции в очередь одну за другой.

1. **Первая функция:** Получает текущий стейт (`0`), прибавляет 1. Возвращает `1`.
    
2. **Вторая функция:** Она запускается **после** первой и получает результат её работы в качестве аргумента `prevState`