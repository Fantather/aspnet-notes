
### Базовый пример
```jsx
// Button.test.jsx
import { render, screen } from "@testing-library/react";
import { describe, it, expect } from "vitest";
import Button from "./Button";

describe("<Button />", () => {
  it("Отображает кнопку с правильным текстом", () => {
    // 1. Рендеринг
    render(<Button label="Click me!" onClick={() => {}} />);

    // 2. Поиск элемента
    const buttonElement = screen.getByRole("button");

    // 3. Проверки (Assertions)
    expect(buttonElement).not.toBeNull();
    expect(buttonElement.textContent).toBe("Click me!");
  });
});
```

### Основные инструменты RTL

**render**
Функция, которая генерирует виртуальную разметку компонента внутри эмулятора браузера (JSDOM). После вызова этой функции компонент «существует» в памяти и доступен для поиска.

**screen**
Объект, предоставляющий методы для поиска элементов в отрендеренном документе. Это основной способ «посмотреть» на результат рендера, как это делает пользователь.

### Стратегии поиска (Queries)

**getByRole**
Ищет элемент по его семантической роли (например, button, heading, link, textbox). Это рекомендуемый способ поиска, так как он гарантирует доступность интерфейса. Если элемент не найден, тест сразу упадет с ошибкой.
```JavaScript
// Найдет <button>...</button>
const btn = screen.getByRole("button");
```

### Проверки (Assertions) в контексте DOM
**Проверка существования (Базовая)**
Использует .not.toBeNull(). Проверяет, что переменная содержит ссылку на объект, а не null.

Примечание: методы getBy... сами выбрасывают ошибку, если ничего не найдено, поэтому эта проверка часто используется с методами queryBy..., которые возвращают null при отсутствии элемента.
``` JavaScript
expect(buttonElement).not.toBeNull();
```


**Проверка текстового содержимого**
Использует свойство .textContent и матчер .toBe(). Мы обращаемся к стандартному свойству DOM-узла, чтобы получить текст внутри тега, и сравниваем его со строкой.

``` JavaScript
// <button>Click me!</button> -> "Click me!"
expect(buttonElement.textContent).toBe("Click me!");
```


### Асинхронность и ожидание элементов
**findBy... (Асинхронный поиск)**
  Используются, когда элемент появляется в DOM *не сразу*, а спустя время (например, после загрузки данных с сервера или завершения анимации).
  
  Методы этой группы (например, `findByRole`, `findByText`) возвращают *Promise*, который разрешается, когда элемент найден. Они "ждут" появления элемента (по умолчанию до 1000 мс), периодически сканируя DOM. Если элемент так и не появился за отведенное время — тест падает.

```javascript
import { render, screen } from "@testing-library/react";
import { describe, it, expect } from "vitest";
import UserProfile from "./UserProfile";

describe("<UserProfile />", () => {
  it("Отображает имя пользователя после загрузки", async () => {
    render(<UserProfile />);

    // Если использовать getByText, тест упадет, так как сначала на экране "Loading..."
    // Используем findByText + await, чтобы подождать появления данных
    const userName = await screen.findByText("Alex");

    expect(userName).toBeInTheDocument();
  });
});
```

**waitFor**
  Универсальная утилита для ожидания любых изменений. Используется реже, чем findBy, обычно для случаев, когда нужно подождать исчезновения элемента или изменения чего-то, что нельзя поймать через запрос элемента. Принимает callback-функцию с утверждением (expect).

``` JavaScript
import { waitFor } from "@testing-library/react";

// Пример: ждем, пока элемент исчезнет (например, лоадер)
await waitFor(() => {
  expect(screen.queryByText("Loading...")).toBeNull();
});
```

### Краткое пояснение разницы (для понимания)
1.  **`getBy...`**: Ищет сейчас. Не нашел — **ошибка**. (Для того, что есть сразу).
2.  **`queryBy...`**: Ищет сейчас. Не нашел — **null**. (Для проверки отсутствия).
3.  **`findBy...`**: Ищет сейчас. Не нашел — **ждет** (до 1сек). Не нашел — **ошибка**. (Для того, что появится асинхронно).