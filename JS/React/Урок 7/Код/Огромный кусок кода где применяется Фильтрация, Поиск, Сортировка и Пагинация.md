```JSX
import React, { useId, useMemo, useState } from "react";

const initialTodos = [

  { id: 1, text: "Learn React", completed: false },

  { id: 2, text: "Build a TodoList", completed: true },

  { id: 3, text: "Review JavaScript", completed: false },

  { id: 4, text: "Read about hooks", completed: false },

  { id: 5, text: "Write unit tests", completed: true },

  { id: 6, text: "Refactor code", completed: false },

  { id: 7, text: "Improve styles", completed: true },

  { id: 8, text: "Add animations", completed: false },

  { id: 9, text: "Optimize performance", completed: false },

  { id: 10, text: "Add accessibility", completed: true },

  { id: 11, text: "Document code", completed: false },

  { id: 12, text: "Publish app", completed: false },

];

/* Constants for filters and sorting */

const FILTERS = {

  ALL: "all",

  ACTIVE: "active",

  COMPLETED: "completed",

};

const SORT_FIELDS = {

  ID: "id",

  TEXT: "text",

  COMPLETED: "completed",

};

function App() {

  const id = useId(); // used only for accessible labels

  const [todos, setTodos] = useState(initialTodos);

  // UI state

  const [statusFilter, setStatusFilter] = useState(FILTERS.ALL);

  const [searchField, setSearchField] = useState("text"); // 'text' | 'id'

  const [searchQuery, setSearchQuery] = useState("");

  const [sortField, setSortField] = useState(SORT_FIELDS.ID);

  const [sortOrder, setSortOrder] = useState("asc"); // 'asc' | 'desc'

  // Pagination state

  const [page, setPage] = useState(1);

  const [pageSize, setPageSize] = useState(5);

  const filteredAndSorted = useMemo(() => {

    // 1) Status filter

    let result = todos.filter((t) => {

      if (statusFilter === FILTERS.ACTIVE) return !t.completed;

      if (statusFilter === FILTERS.COMPLETED) return t.completed;

      return true; // ALL

    });

    // 2) Search

    const query = searchQuery.trim();

    if (query !== "") {

      if (searchField === "id") {

        const qNum = Number(query);

        if (!Number.isNaN(qNum)) {

          result = result.filter((t) => t.id === qNum);

        } else {

          result = [];

        }

      } else {

        const qLower = query.toLowerCase();

        result = result.filter((t) => t.text.toLowerCase().includes(qLower));

      }

    }

    // 3) Sorting

    result = [...result].sort((a, b) => {

      let cmp = 0;

      if (sortField === SORT_FIELDS.ID) {

        cmp = a.id - b.id;

      } else if (sortField === SORT_FIELDS.TEXT) {

        cmp = a.text.localeCompare(b.text);

      } else if (sortField === SORT_FIELDS.COMPLETED) {

        cmp = a.completed === b.completed ? 0 : a.completed ? 1 : -1;

      }

      return sortOrder === "asc" ? cmp : -cmp;

    });

    return result;

  }, [todos, statusFilter, searchField, searchQuery, sortField, sortOrder]);

  /* Pagination */

  const totalItems = filteredAndSorted.length;

  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));

  if (page > totalPages) {

    setPage(totalPages);

  }

  const startIndex = (page - 1) * pageSize;

  const paginatedTodos = filteredAndSorted.slice(

    startIndex,

    startIndex + pageSize

  );

  /* Toggle completed state */

  function toggleCompleted(todoId) {

    setTodos((prev) =>

      prev.map((t) => (t.id === todoId ? { ...t, completed: !t.completed } : t))

    );

  }

  return (

    <div style={styles.container}>

      <h1 style={styles.h1}>

        TodoList — Filtering, Search, Sorting & Pagination

      </h1>

      {/* Status filter */}

      <div style={styles.controlsRow}>

        <div style={styles.group}>

          <strong>Status:</strong>

          <div>

            <button

              onClick={() => {

                setStatusFilter(FILTERS.ALL);

                setPage(1);

              }}

              disabled={statusFilter === FILTERS.ALL}

              style={styles.smallBtn(statusFilter === FILTERS.ALL)}

            >

              All

            </button>

            <button

              onClick={() => {

                setStatusFilter(FILTERS.ACTIVE);

                setPage(1);

              }}

              disabled={statusFilter === FILTERS.ACTIVE}

              style={styles.smallBtn(statusFilter === FILTERS.ACTIVE)}

            >

              Active

            </button>

            <button

              onClick={() => {

                setStatusFilter(FILTERS.COMPLETED);

                setPage(1);

              }}

              disabled={statusFilter === FILTERS.COMPLETED}

              style={styles.smallBtn(statusFilter === FILTERS.COMPLETED)}

            >

              Completed

            </button>

          </div>

        </div>

        {/* Search */}

        <div style={styles.group}>

          <label htmlFor={`${id}-search`}>Search:</label>

          <div style={{ display: "flex", gap: 8, alignItems: "center" }}>

            <select

              value={searchField}

              onChange={(e) => {

                setSearchField(e.target.value);

                setSearchQuery("");

                setPage(1);

              }}

            >

              <option value="text">By text</option>

              <option value="id">By ID</option>

            </select>

            <input

              id={`${id}-search`}

              placeholder={

                searchField === "id" ? "Enter ID (number)" : "Search in text..."

              }

              value={searchQuery}

              onChange={(e) => {

                setSearchQuery(e.target.value);

                setPage(1);

              }}

              style={styles.input}

            />

            <button

              onClick={() => {

                setSearchQuery("");

                setPage(1);

              }}

              style={styles.smallBtn(false)}

            >

              Reset

            </button>

          </div>

          <div style={styles.note}>

            Note: when searching by ID, only numeric input is valid.

          </div>

        </div>

        {/* Sorting */}

        <div style={styles.group}>

          <label>Sorting:</label>

          <div style={{ display: "flex", gap: 8 }}>

            <select

              value={sortField}

              onChange={(e) => {

                setSortField(e.target.value);

                setPage(1);

              }}

            >

              <option value={SORT_FIELDS.ID}>By ID</option>

              <option value={SORT_FIELDS.TEXT}>By text</option>

              <option value={SORT_FIELDS.COMPLETED}>By completed</option>

            </select>

            <select

              value={sortOrder}

              onChange={(e) => {

                setSortOrder(e.target.value);

                setPage(1);

              }}

            >

              <option value="asc">Ascending</option>

              <option value="desc">Descending</option>

            </select>

          </div>

        </div>

      </div>

      {/* Stats */}

      <div style={styles.metaRow}>

        <div>Total: {todos.length}</div>

        <div>After filters: {totalItems}</div>

        <div>Active: {todos.filter((t) => !t.completed).length}</div>

        <div>Completed: {todos.filter((t) => t.completed).length}</div>

      </div>

      {/* Todo list */}

      <div style={styles.listCard}>

        <ul style={styles.ul}>

          {paginatedTodos.length === 0 ? (

            <li style={styles.empty}>No tasks found</li>

          ) : (

            paginatedTodos.map((todo) => (

              <li key={todo.id} style={styles.li}>

                <label

                  style={{

                    display: "flex",

                    gap: 12,

                    alignItems: "center",

                    width: "100%",

                  }}

                >

                  <input

                    type="checkbox"

                    checked={todo.completed}

                    onChange={() => toggleCompleted(todo.id)}

                  />

                  <span

                    style={todo.completed ? styles.textCompleted : undefined}

                  >

                    {todo.text}

                    <span style={styles.small}> (id: {todo.id})</span>

                  </span>

                </label>

              </li>

            ))

          )}

        </ul>

      </div>

      {/* Pagination */}

      <div style={styles.pagination}>

        <div>

          <button

            onClick={() => setPage((p) => Math.max(1, p - 1))}

            disabled={page === 1}

            style={styles.smallBtn(page === 1)}

          >

            ← Prev

          </button>

          <span style={{ margin: "0 12px" }}>

            Page {page} of {totalPages}

          </span>

          <button

            onClick={() => setPage((p) => Math.min(totalPages, p + 1))}

            disabled={page === totalPages}

            style={styles.smallBtn(page === totalPages)}

          >

            Next →

          </button>

        </div>

        <div style={{ display: "flex", gap: 8, alignItems: "center" }}>

          <label htmlFor={`${id}-pagesize`}>Page size:</label>

          <select

            id={`${id}-pagesize`}

            value={pageSize}

            onChange={(e) => {

              setPageSize(Number(e.target.value));

              setPage(1);

            }}

          >

            <option value={3}>3</option>

            <option value={5}>5</option>

            <option value={10}>10</option>

          </select>

        </div>

      </div>

      <div style={styles.noteBlock}>

        <strong>Key takeaways:</strong>

        <ul>

          <li>Always apply filters and search before pagination.</li>

          <li>

            Use a stable <code>key</code> (like <code>todo.id</code>) for list

            items.

          </li>

          <li>

            <code>useMemo</code> helps optimize expensive list operations.

          </li>

          <li>

            Reset pagination when filters/search/sort change for better UX.

          </li>

        </ul>

      </div>

    </div>

  );

}

/* --- Inline styles for a clean, self-contained example --- */

const styles = {

  container: {

    fontFamily: "Inter, Roboto, system-ui, sans-serif",

    maxWidth: 900,

    margin: "24px auto",

    padding: 20,

    border: "1px solid #e5e7eb",

    borderRadius: 8,

    background: "#fff",

  },

  h1: { marginTop: 0, marginBottom: 12 },

  controlsRow: {

    display: "flex",

    gap: 16,

    flexWrap: "wrap",

    marginBottom: 12,

  },

  group: {

    minWidth: 220,

    display: "flex",

    flexDirection: "column",

    gap: 6,

  },

  note: { fontSize: 12, color: "#6b7280" },

  metaRow: { display: "flex", gap: 12, marginBottom: 12, color: "#374151" },

  listCard: {

    borderTop: "1px solid #e5e7eb",

    paddingTop: 12,

    marginBottom: 12,

  },

  ul: { listStyle: "none", margin: 0, padding: 0 },

  li: { padding: "8px 6px", borderBottom: "1px dashed #f3f4f6" },

  empty: { color: "#6b7280", padding: 12 },

  small: { fontSize: 12, color: "#6b7280", marginLeft: 8 },

  textCompleted: {

    textDecoration: "line-through",

    color: "#9ca3af",

  },

  pagination: {

    display: "flex",

    justifyContent: "space-between",

    alignItems: "center",

    gap: 8,

  },

  smallBtn: (disabled) => ({

    padding: "6px 10px",

    borderRadius: 6,

    border: "1px solid #d1d5db",

    background: disabled ? "#f3f4f6" : "#fff",

    cursor: disabled ? "not-allowed" : "pointer",

  }),

  input: {

    padding: "6px 8px",

    borderRadius: 6,

    border: "1px solid #e5e7eb",

    minWidth: 160,

  },

  noteBlock: {

    marginTop: 14,

    paddingTop: 12,

    borderTop: "1px solid #e5e7eb",

  },

};

export default App;
```