![[Pasted image 20251106190357.png]]
## Замыкания (Closures)

> **Замыкание** — это функция, которая "запоминает" свое внешнее лексическое окружение (scope) и сохраняет доступ к переменным из этого окружения, **даже если** внешняя (родительская) функция уже завершила свое выполнение.

### Как это работает: `[[Environment]]`

Когда в JavaScript создается функция, она получает не только свой код, но и скрытую ссылку на лексическое окружение, в котором она была создана. Эта ссылка технически называется `[[Environment]]`.

Эта ссылка "запирает" внешние переменные, делая их доступными для внутренней функции в любой момент в будущем.

### Разбор примера

классический пример "фабрики функций", которая работает благодаря замыканиям.



```JavaScript
let g_var = 2;

function multiply(n) {
  // 1. Эта область (scope) функции 'multiply'
  // 'n' - это параметр, 'x' - локальная переменная
  var x = n;
  
  // 2. 'multiply' возвращает НОВУЮ анонимную функцию
  return function (m) {
    // 3. Эта внутренняя функция и есть ЗАМЫКАНИЕ.
    // Она "помнит" 'x' и 'g_var'
    return x * m * g_var; 
  };
}
```

#### Шаг 1: Создание замыкания

```JavaScript
var fn1 = multiply(5);
```

1. Вызывается `multiply(5)`.
    
2. Внутри `multiply` локальная переменная `x` получает значение `5`.
    
3. `multiply` **возвращает** внутреннюю анонимную функцию `function (m) { ... }`.
    
4. В этот момент **создается замыкание**: возвращаемая функция "захватывает" и "помнит", что в ее родительском окружении `x` был равен `5`.
    
5. Функция `multiply(5)` завершает свою работу (ее контекст уходит из стека).
    
6. Переменная `fn1` теперь хранит эту новую функцию, которая "помнит" `x = 5`.
    

`fn1` — это, по сути, функция `function (m) { return 5 * m * g_var; }`.

#### Шаг 2: Вызов замыкания

```JavaScript
var result1 = fn1(6);
```

1. Вызывается `fn1` (наше замыкание) с аргументом `m = 6`.
    
2. Функция ищет значения нужных ей переменных:
    
    - `m`: находит в своем локальном окружении (это `6`).
        
    - `x`: не находит локально. Она ищет в своем "запомненном" внешнем окружении (замыкании) и находит там `x = 5`.
        
    - `g_var`: не находит ни локально, ни в окружении `multiply`. Она продолжает поиск вверх по "цепочке областей видимости" (scope chain) и находит `g_var = 2` в глобальном окружении.
        
3. Выполняется вычисление: `5 * 6 * 2`.
    
4. `result1` получает значение `60`.

![[Pasted image 20251106190911.png]]
тут создается ф-ция, она возвращает ф-цию и передает ей 6
![[Pasted image 20251106191021.png]]

объявили и она себя вызвала
![[Pasted image 20251106191344.png]]
