![[Pasted image 20251107203412.png]]
мы на лету добавим ф-ции
мы можем обратишься к тому что создано на объекте (статически)
![[Pasted image 20251107203520.png]]

Статические функции (или, точнее, **статические методы**) в JavaScript — это функции, которые принадлежат самому классу, а не его отдельным экземплярам (объектам).

Ключевое отличие в том, что для вызова статического метода **не нужно создавать объект** этого класса. Вы обращаетесь к нему напрямую через имя класса.

---

### Основные характеристики

- **Принадлежность классу:** Они вызываются непосредственно на классе: `ClassName.staticMethod()`.
    
- **Отсутствие `this` (экземпляра):** Внутри статического метода `this` ссылается на сам класс (конструктор), а не на экземпляр. Из-за этого статические методы не могут напрямую обращаться к свойствам экземпляра (таким как `this.name` или `this.age`).
    
- **Ключевое слово `static`:** Для объявления такого метода используется ключевое слово `static` перед именем функции внутри определения класса.
    

---

### Синтаксис и примеры

```JavaScript
class User {
  constructor(name) {
    this.name = name; // Свойство экземпляра
  }

  // 1. Метод экземпляра (обычный)
  // Принадлежит объекту, нужен экземпляр для вызова
  greet() {
    console.log(`Привет, меня зовут ${this.name}`);
  }

  // 2. Статический метод
  // Принадлежит классу, экземпляр не нужен
  static sayHello() {
    console.log("Привет! Это статический метод класса User.");
    // 'this' здесь ссылается на класс User, а не на объект
    // console.log(this.name); // Выдаст 'undefined', т.к. 'name' есть у экземпляра, а не у класса
  }
}

// --- Использование ---

// Вызов статического метода (объект не нужен)
User.sayHello(); // Вывод: Привет! Это статический метод класса User.

// Создание экземпляра
const user1 = new User("Иван");

// Вызов метода экземпляра (нужен объект)
user1.greet(); // Вывод: Привет, меня зовут Иван

// Попытка вызвать статический метод на экземпляре приведет к ошибке
// user1.sayHello(); // Ошибка: user1.sayHello is not a function
```

---

### Когда использовать статические методы?

Статические методы подходят для создания **вспомогательных функций (утилит)** или **"фабричных" методов**, которые логически связаны с классом, но не требуют данных конкретного объекта.

#### 1. Утилитарные функции

Представьте, что вам нужна функция, которая что-то делает _для_ класса или _с_ данными класса, но не зависит от одного объекта.

Встроенный в JavaScript класс `Math`. Вы никогда не создаете `new Math()`. Вы просто используете его статические методы:

- `Math.random()`
    
- `Math.max(10, 20)`
    
- `Math.floor(1.5)`
    

**пример:**

 ```JavaScript
class MathUtils {
  static PI = 3.14159;

  static sum(a, b) {
    return a + b;
  }
  
  static circleArea(radius) {
    // Мы можем обращаться к другим статическим свойствам через 'this' (т.к. this = класс)
    return this.PI * radius * radius;
  }
}

console.log(MathUtils.sum(5, 10)); // Вывод: 15
console.log(MathUtils.circleArea(10)); // Вывод: 314.159
```

#### 2. Фабричные методы

Это статические методы, которые используются для создания и возврата новых экземпляров класса. удобно, когда у вас есть несколько способов создать объект.

```JavaScript
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // Обычный конструктор
  // new User("Иван", "ivan@test.com");

  // Статический "фабричный" метод для создания гостя
  static createGuest() {
    return new User("Гость", "guest@example.com");
  }

  // Статический метод для создания пользователя из объекта с данными
  static fromData(data) {
    // data = { username: 'petr', userEmail: 'petr@test.com' }
    return new User(data.username, data.userEmail);
  }
}

// Создаем объекты разными способами:
const guest = User.createGuest();
const petr = User.fromData({ username: 'Петр', userEmail: 'petr@test.com' });

console.log(guest.name); // Вывод: Гость
console.log(petr.name); // Вывод: Петр
```
