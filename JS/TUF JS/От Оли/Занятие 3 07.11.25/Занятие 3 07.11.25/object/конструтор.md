![[Pasted image 20251107190431.png]]
![[Pasted image 20251107190405.png]]
мы через this обращаемся к this этого объекта и заполняем его, сама function будет видеть this как поля объекта
![[Pasted image 20251107190532.png]]
мы создаем его через new он тогда создаст его КАК ОБЪЕКТ
![[Pasted image 20251107190615.png]]
имя метода,
![[Pasted image 20251107190622.png]]
для вызова все равно нужны круглые скобки, потому что это метод все равно


![[Pasted image 20251107191321.png]]
мы можем инкапсулировать через замыкание и держатся они через замыкание
он один раз отработал черз конструктор и переменные держатся через замыкание, а не разрушены. Мы так их спрятали через let и var переменные, инкапсулировав их
а замыкание держит их от разрушения

![[Pasted image 20251107191439.png]]
___
## Инкапсуляция через Замыкание

- **Сокрытие данных:** Переменная, объявленная внутри конструктора через `let` или `var` (в вашем примере `let firstName`), **не является свойством `this`**. Она "приватная" и доступна только внутри конструктора.
    
- **Замыкание:** Методы, которые создаются внутри этого же конструктора (как `this.getFirstName`), "захватывают" эту переменную `firstName` в свое лексическое окружение.
    
- **Сохранение:** Когда конструктор отработал, эта переменная `firstName` **не разрушается** сборщиком мусора, потому что на нее все еще ссылается метод `getFirstName`. Она "живет" в замыкании.
    

**Результат:** Вы не можете получить доступ к `user.firstName` (оно будет `undefined`, как на вашем скриншоте), но можете получить его значение, вызвав "публичный" метод `user.getFirstName()`. Вы успешно **инкапсулировали** (спрятали) данные.

``` JavaScript
function User(name) {
    // Шаг 1: Создается "приватная" переменная
    // Эта переменная 'firstName' существует ТОЛЬКО внутри функции User.
    // К ней нельзя получить доступ снаружи (например, user.firstName).
    let firstName = name;

    // Шаг 2: Создается "публичный" метод
    // Этот метод является свойством объекта 'this'.
    // Он будет доступен снаружи (например, user.getFirstName()).
    this.getFirstName = function() {
        // Шаг 3: Происходит "Замыкание"
        // 
        // Когда этот метод создается, он "видит" переменную 'firstName' 
        // из своей родительской области видимости (функции User).
        // 
        // Он "захватывает" эту переменную и будет иметь к ней доступ
        // всегда, пока сам метод 'getFirstName' существует.
        return firstName; 
    };

    // ... другие методы, которые тоже "видят" firstName ...
}

// Шаг 4: Вызов конструктора
let user = new User("Иван");

// К этому моменту функция User() УЖЕ ЗАВЕРШИЛАСЬ.
// Казалось бы, ее локальная переменная 'firstName' должна быть уничтожена.
```

- **Переменная `firstName` не уничтожена.** Почему? Потому что на нее все еще **ссылается** метод `user.getFirstName`, который "живет" внутри объекта `user`. Этот механизм удержания переменной и называется **замыканием**. Переменная `firstName` "замкнута" в лексическом окружении метода `getFirstName`.
    
- **Доступ снаружи невозможен:**
    
    - `console.log(user.firstName);` // Выдаст `undefined`
        
    - Вы не можете напрямую прочитать или изменить `firstName`.
        
- **Доступ через метод возможен:**
    
    - `console.log(user.getFirstName());` // Выдаст "Иван"
        
    - Вы можете _только_ через "публичный" метод `getFirstName` получить данные.

___

