Эта версия наследования хранит методы в this, поэтому каждый объект Функции будет хранить свою версию объектов в памяти, что бы этого избежать используют прототипы и прототипное наследование
#### Родительский класс
![[Pasted image 20251107192136.png]]
![[Pasted image 20251107192159.png]]
![[Pasted image 20251107192226.png]]


**Дочерний класс**
`call` привязывает `Person` к конкретному объекту `Student`
Теперь, когда к `this` у `Person` будет 

![[Pasted image 20251107192819.png]]




Для организации наследования используются два ключевых слова: `extends` и `super`.

### 1. Синтаксис наследования

Чтобы создать класс-наследник (дочерний класс), мы используем ключевое слово **`extends`** в объявлении класса. Это говорит интерпретатору: «Этот новый класс должен перенять все свойства и методы родительского класса».

### 2. Ключевое слово `super`

Это критически важный механизм. В конструкторе наследника (в методе `constructor`) мы обязаны вызвать **`super()`** перед тем, как обращаться к ключевому слову `this`.

- **`super(...)`** — вызывает конструктор родительского класса. Это позволяет инициализировать свойства, которые определены в родителе.
    
- **`super.methodName()`** — позволяет вызвать метод родителя внутри метода наследника (например, если мы хотим расширить функционал метода, а не полностью его перезаписать).
    

### Пример структуры

Допустим, у нас есть базовый класс `BaseComponent`:

JavaScript

```
class BaseComponent {
    constructor(name) {
        this.name = name; // Инициализация свойства родителя
    }

    log() {
        console.log("Базовый лог: " + this.name);
    }
}
```

А теперь создадим наследника `ExtendedComponent`:

JavaScript

```
// Используем extends для наследования
class ExtendedComponent extends BaseComponent {
    constructor(name, version) {
        // Сначала обязательно вызываем конструктор родителя
        super(name); 
        
        // Только после super() можно использовать this
        this.version = version; 
    }

    // Этот класс наследует метод log(), но может иметь и свои методы
    getVersion() {
        console.log("Версия: " + this.version);
    }
}
```

### Как это применить к твоему заданию

У тебя есть задача создать `SimpleMarker` (родитель) и `RefillableMarker` (наследник).

В задании сказано:

1. **`SimpleMarker`** имеет поля `color` и `inkAmount` (в %).
    
2. **`RefillableMarker`** наследуется от простого и добавляет метод заправки.
    

Давай начнем с малого. Опираясь на пример выше, попробуй написать только **объявление класса** `RefillableMarker` (первую строку) и его **конструктор**.

Какие параметры, по-твоему, должен принимать конструктор заправляемого маркера, и какие из них нужно передать в `super()`?