*CancellationTokenSourse* (Источник отмены)- Это объект-владелец. Его единственная задача - управлять сигналом отмены
Когда мы вызываем `cts.Cancel()`, он просто меняет свое внутреннее состояние (и состояние всех связанных с ним токенов) на "отменено"

Ему все равно, "слушает" ли кто-то этот сигнал или нет, поэтому если при `Cancel` у CTS не окажется токенов, которые были бы с ним связаны, то ничего не произойдёт


*CancellationToken* (Токен отмены): Это "посыльный". Мы передаём его в свои методы

Методы *обязаны* сами периодически проверять состояние этого токена (например, через `token.IsCancellationRequested` или `token.ThrowIfCancellationRequested()`)


#### Как работает отмена
Что бы отменить выполнение метода в отдельном потоке, в параметры метода передаётся структура *CancellationToken*, который генерируется с помощью объекта класса *CancellationTokenSourse*

На объекте *CancellationTokenSourse*, который сгенерировал *CancellationToken* вызывается метод `Cancel()`, который и генерирует отмену
После вызова `Cancel()` всегда нужно освобождать ресурсы у *CTS* через `Dispose()` и создать новый объект *CTS*

Внутри же метода, через *CancellationToken* мы используем или свойство `IsCancellationRequested`, которое станет true, если был вызван метод `Cancel()`
Или метод `ThrowIfCancellationRequested`, который вызывает исключение *OperationCanceledException*

Что бы мы не использовали, исключение *OperationCanceledException* должно быть передано наружу метода


