*Async/Await* это синтаксический сахар, который упрощает синтаксис написания Асинхронных методов и лишает необходимости волноваться об исключениях, которые могут быть забыты в одном из потоков

То есть async await были созданы, что бы написание асинхронного кода было таким же простым, как и написание синхронного кода

Если *Async* методы что-то возвращают, то они автоматически генерируют *Task* в который оборачивают результат и возвращают его немедленно, но результата там может и не быть
Этот автоматически сгенерированный Task *обещает* результат когда-то в будущем и позволяет потоку продолжать свою работу
Он приобретёт состояние *RanToCompletion*, только когда метод полностью закончится, даже если код в этом методе выполняется в вызвавшем его потоке

У async-метода в названии *должно быть написано Async*, что бы другие программисты понимали, что в методе используется `await` и что вызов нужно обрабатывать асинхронно, вероятно тоже через `await`
Это не техническое требование, но важное соглашение

#### Async
Ключевое слово `async` пишется в сигнатуре метода, благодаря ему компилятор понимает что внутри этого метода будет использоваться `await`

А так же заворачивает значение, которое мы возвращаем из метода в *Task*, очевидно что возвращаемый тип должен соответствовать тому, что возвращает Task прописанный в сигнатуре метода

`async` методы всегда должны возвращать Task, что бы исключение вызванное внутри async-метода могло быть отловлено try catch
Только обработчики событий могут быть `async void`
Иначе исключение вызванное внутри обычного async-метода будет выброшено прямо в UI-поток и это может привести к аварийному закрытию программы

```C#
public async Task<string> MyMethodAsync()
{
	Task<string> task = Task.Run(() =>
	{
		return "Result";
	});
	
	return await task;
}
```


#### Await
Пишется внутри метода, с ключевым словом `async`
Не блокирует поток, но метод в котором он был вызван будет ожидать выполнения *Task*, к которому его применили
А пока метод ожидает - поток продолжит выполнение вызывающего кода


Когда *Task* будет завершён, любой код который использовал `await`, то есть ожидал этот *Task* в этот момент пробудится, извлекает результат из *Task* и продолжает своё выполнение

Если *Task* был создан в ThreadPool, то выполнение продолжится в любом потоке из пула
Если же *Task* был создан в UI-потоке, то `await` захватит *SynchronizationContext* и при завершении *Task* выполнение кода продолжится в UI-потоке

```C#
public async Task MyMethodAsync()
{
	Task<string> task = Task.Run(() =>
	{
		return "Result";
	});
	
	MessageBox.Show(await task);
}
```


#### Вызов async-метода
Такой метод вызывается так же как и обычные, но компилятор не ждёт его выполнения, а идёт дальше
Так же, к такому методу можно применить `await`, ведь async-метод возвращает Task, если вообще что-то возвращает


```C#
static void Main(string[] args)
{
	Task.Run(() => Testing());
}

public async void Testing()
{
	MyMethodAsync();
	Task<string> resultTask = MyMethodStringAsync();
	string resultString = await MyMethodStringAsync();
	
	// Код тут будет ожидать завершения await метода
}
```

`Task.Run(() => Testing());` - Представим что метод запустился в UI-потоке

`MyMethodAsync();` - Компилятор не будет ждать выполнения этого метода и пойдёт дальше

`Task<string> resultTask = MyMethodStringAsync();`
Мы получим не распакованный `Task<string>`, вредный вариант, ведь что бы получить отсюда результат, нам придётся использовать свойство `Result`, которое блокирует UI-поток
И из-за того что мой метод в конце возвращает управление в UI-поток, то тут произойдёт взаимная блокировка
То есть `resultTask.Result;` будет ждать пока `resultTask` завершится и блокировать UI-поток, а `resultTask`, который возвращает управление этому UI-потоку не сможет завершиться, ведь UI-поток заблокирован

`string result = await MyMethodAsync();`
`MyMethodAsync()` вернёт Task сразу же и поток сможет продолжить своё выполнение, но результата в нём пока может и не быть
Из-за того что мы тут написали `await` наш метод будет ожидать выполнения метода `MyMethodStringAsync()` и в это время управление вернётся к UI-потоку, благодаря чему, наш графический интерфейс не зависнет

