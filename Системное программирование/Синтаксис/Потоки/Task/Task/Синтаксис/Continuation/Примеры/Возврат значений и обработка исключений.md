Существует два подхода для обработки результата, полученного в другом потоке

#### Работа через if
Мы проверяем, возникли ли исключения внутри потока
Если да, то обращаемся к свойству *Exception* у объекта *Task*, в нём содержатся все исключения, которые не были отловлены в потоке в виде объектов класса *Exception*

Этот подход Семантически чище и более читаем, чем "Активное" наблюдение описанное ниже
```C#
// Полностью соблюдаем принцип единственной ответсвенности (SRP)
myFirstTask.ContinueWith(task =>
{
   if (task.IsCompletedSuccessfully)
   {
       HandleSuccess(task.Result);
   }
   else if (task.IsFaulted)
   {
       HandleFailure(task.Exception);
   }
   else if (task.IsCanceled)
   {
       HandleCancellation();
   }
});
```


Так же мы можем использовать `TaskContinuationOptions` и указать с каким состоянием должен завершиться Task, что бы запустился Continuation-метод

Continuation-метод запустится, только если myFirstTask завершился из-за необработанного исключения, так что тут необходимо обработать ошибку
```C#
// Возможно, лучше обрабатывать исключения в отдельном методе, если обработка требуется в нескольких местах кода
myFirstTask.ContinueWith(task =>
{
	foreach(Exception ex in task.Exception)
	{
		Console.WriteLine(ex);
	}
}, TaskContinuationOptions.OnlyOnFaulted);
```

#### Работа через Исключения
Мы вызываем свойство `Result` и готовы отловить исключение *AggregateException*, которое может вызвать это свойство

Не так эффективно, как использование свойства *Exception*, потому что вызов исключения ресурсоёмкая операция
Кроме того, в таком подходе действия при *возникновении Исключения* и использовании *CancellationToken* сливаются
Но такой подход тоже допустим
```C#
myFirstTask.ContinueWith(task =>
{
   try
   {
	   Console.WriteLine(task.Result);
   }
   catch (AggregateException ae)
   {
	   foreach(Exception ex in ae.InnerExceptions)
	   {
		   Console.WriteLine(ex.Message);
	   }
   }
}
```