#### Первый способ
```C#
Task<int> task = Task.Run(SomeMethod);
int result = task.Result;
```
`Result` - Возвращает результат работы метода в параметризованном Task
Это блокирующий метод, который заставит поток ожидать результата, для продолжения
Он возвращает значение только если [[Состояния|Статус завершения]] у Task был *RanToComplete*

Если Task был завершён из-за не отловленного Исключения, то вместо возврата значения `Result` вызовет *Aggreagate Exception*
Так же, если в потоке было отловлено исключение *OperationCancelledException*, то *Aggreagate Exception* будет содержать в себе *TaskCanceledException*

*Aggreagate Exception* - Исключение, внутри которого завёрнуты другие Исключения, произошедшие в потоке
Для их просмотра у *Aggreagate Exception* есть свойство *InnersException*


#### Второй способ
Так же в Continuation можно ожидать результат выполнения первоначального метода и в отдельном потоке этот результат обработать, не заставляя Main ожидать этот результат


#### Третий способ
Эти методы блокируют основной поток
`Task.Wait()` - Блокирует поток, пока переданный task не завершит работу
```C#
Task.Wait(task);
```

`Task.WaitAll()` - Блокирует поток, пока все переданные объекты Task не завершат работу
```C#
int firstFinishedIndex = Task.WaitAll(task1, task2);
```

`Task.WaitAny()` - Блокирует поток, пока один из переданных Task не завершит работу
Возвращает индекс первого завершившего свою работу Task, но что бы этот индекс имел смысл, в `WaitAny()` обычно передают массив Task

Не останавливает выполнение остальных переданных методов
Так что если переданные задачи сложны, то стоит использовать на них *CancellationToken*

```C#
Task[] tasks = { task1, task2 };
int firstFinishedIndex = Task.WaitAny(tasks);
```

`Task.WaitAll()` и `Task.WaitAny()` под капотом объединяют переданные объекты Task в массив, поэтому они могут принимать как массив Task, так и объекты по отдельности


#### Четвёртый способ
Эти методы не блокируют основной поток
`Task.WhenAll()` - Не блокирует основной поток, сразу возвращает объект Task, внутри которого выполняются все переданные Task

Пока все Task внутри не завершат работу, у него будет статус *Running*
Когда Task успешно завершатся,  внешний Task перейдёт в статус *RanToCompletion*
```C#
// Немедленно получаем внешний Task (metaTask)
// Приложение не будет ожидать их завершения, если мы не добавим ReadLine/Wait
Task metaTask = Task.WhenAll(t1, t2);

// Даём metaTask инструкцию, что делать ПОСЛЕ
metaTask.ContinueWith(task => 
{
    Console.WriteLine("WhenAll завершён! Обе задачи (t1 и t2) закончили.");
});
```

`Task.WhenAny()` - Не блокирует основной поток, сразу возвращает объект `Task<Task>`, внутри которого выполняются все переданные Task
Свойство `Result` Возвращает объект Task, который завершил свою работу быстрее всего

Не останавливает выполнение остальных переданных методов
Так что если переданные задачи сложны, то стоит использовать на них *CancellationToken*

```C#
// metaTask вернёт нам объект Task, который завершится первым
Task<Task> metaTask = Task.WhenAny(t1, t2);

// Говорим metaTask, что делать дальше
metaTask.ContinueWith(completedMetaTask => 
{
    // мы можем безопасно получить .Result из metaTask
    Task winningTask = completedMetaTask.Result;
    Console.WriteLine($"Победила задача t2. Её статус: {winningTask.Status}");
});
```

Пока первый Task внутри не завершит работу, у него будет статус *Running*
Когда первый Task успешно завершится,  внешний Task перейдёт в статус *RanToCompletion*