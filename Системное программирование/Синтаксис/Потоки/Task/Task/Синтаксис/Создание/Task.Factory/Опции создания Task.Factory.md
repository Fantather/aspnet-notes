Самая полная сигнатура конструктора `Task.Factory`
```C#
Task.Factory.StartNew(
    Func func, // 1. Код, который нужно выполнить
    CancellationToken cancellationToken, // 2. Токен отмены
    TaskCreationOptions creationOptions, // 3. Особые "флаги"
    TaskScheduler scheduler // 4. Выбираем планировщик потоков
);
```

#### Action или Func
Принимает:
- Метод, который _не_ принимает параметров и _не_ возвращает значения
- Метод, который *не* принимает параметров и *возвращает* значение типа `TResult`
  
На пример `() => { Console.WriteLine("Привет"); }` и `Task.Factory` вернёт `Task`
На пример `() => { return 42; }` (это `Func<int>`) и `Task.Factory` вернёт `Task<int>`

Так же мы можем завернуть не подходящий метод в лямбду, которая подходит под требуемую конструктором Сигнатуру
```C#
Task<int> taskInt = Task.Factory.StartNew
(
	() => { return Sum(1, 2, 3, 4); },
	CancellationToken.None,
	TaskCreationOptions.None,
	TaskScheduler.Default
);
```

#### CancellationToken
Мы передаём *CancellationToken*  в Task.Factory для двух вещей
- Когда мы отменяем токен и выбрасываем наружу метода исключение *OperationCancelledException*, TPL отлавливает это исключение и пытается понять, это ожидаемое исключение или сторонняя ошибка?
  Для ответа на этот вопрос TPL сравнивает токен, который был у *OperationCancelledException* и токен, который мы передали в Task
  Если они совпадают, то ошибка была ожидаемой и переводит Task в состояние *TaskStatus.Cancelled*
  Если не передать Токен или токены не будут совпадать, то TPL не поймёт что это исключение связано с отменой этой задачи и переведёт Task в состояние *TaskStatus.Faulted*
  
- Что бы выбранный Планировщик потоков мог увидеть что помещённый в очередь выполнения Task был отменён и даже не пытался его запустить


#### TaskCreationOptions
Это "флаги", которые меняют поведение Task
- *LongRunning* - говорит планировщику о том что задача будет выполняться очень долго и для неё следует создать новый поток(Thread), который не будет частью Thread Pool и закроется, как только задача закончится
  
  Если попытаться использовать этот флаг при отправке задачи Планировщику Контекста Синхронизации, то он его проигнорирует, потому что работает с одним конкретным потоком
  
  
- *PreferFairness* - говорит планировщику поставить задачу, которая прописана в `ContinueWith` в общую очередь, а не пытаться выполнить её *вне* очереди(что Task иногда делает для оптимизации)
  
  Используется очень редко, что бы вызов из сотен `ContinueWith` не вызвал переполнение Стека, ведь все эти вызовы будут там копиться, пока цепочка `ContinueWith` не закончится


- *DenyChildAttach* - Говорит, что родительский Task может не ждать запущенных внутри неё дочерних Task и их статус (Faulted) никак не отразятся на родительском Task

#### TaskScheduler
- *TaskScheduler.Current* - используется по умолчанию, это флаг говорит передать метод в планировщик текущего Task
  
  То есть Task.Factory вызванный внутри другого Task будет передан тому-же планировщику потоков, что считается не совсем очевидным поведением
  Что бы метод был передан в ThreadPool, нужно указать *TaskScheduler.Default*
  
- [[Планировщик задач .NET#TaskScheduler.Default|TaskScheduler.Default]] - передаёт метод планировщику .NET, то есть в ThreadPool
  
- [[Планировщик задач .NET#TaskScheduler.FromCurrentSynchronizationContext()|TaskScheduler.FromCurrentSynchronizationContext()]] - передаёт метод текущему Планировщику Контекста Синхронизации, то есть в UI-поток