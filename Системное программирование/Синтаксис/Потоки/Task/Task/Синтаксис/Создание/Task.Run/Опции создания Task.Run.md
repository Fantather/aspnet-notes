Самая полная сигнатура конструктора `Task.Run`
```C#
public static Task Run(
    Action action, 
    CancellationToken cancellationToken
)
```

#### Action или Func
Принимает:
- Метод, который _не_ принимает параметров и _не_ возвращает значения
- Метод, который *не* принимает параметров и *возвращает* значение типа `TResult`
  
На пример `() => { Console.WriteLine("Привет"); }` и `Task.Run` вернёт `Task`
На пример `() => { return 42; }` (это `Func<int>`) и `Task.Run` вернёт `Task<int>`

Так же мы можем завернуть не подходящий метод в лямбду, которая подходит под требуемую конструктором Сигнатуру
```C#
Task<int> taskInt = Task.Run<int>(() => Sum(1, 2, 3, 4));
```


#### CancellationToken
Мы передаём *CancellationToken*  в Task.Run для двух вещей
- Когда мы отменяем токен и выбрасываем наружу метода исключение *OperationCancelledException*, TPL отлавливает это исключение и пытается понять, это ожидаемое исключение или сторонняя ошибка?
  Для ответа на этот вопрос TPL сравнивает токен, который был у *OperationCancelledException* и токен, который мы передали в Task
  Если они совпадают, то ошибка была ожидаемой и переводит Task в состояние *TaskStatus.Cancelled*
  Если не передать Токен или токены не будут совпадать, то TPL не поймёт что это исключение связано с отменой этой задачи и переведёт Task в состояние *TaskStatus.Faulted*
  
- Что бы выбранный Планировщик потоков мог увидеть что помещённый в очередь выполнения Task был отменён и даже не пытался его запустить