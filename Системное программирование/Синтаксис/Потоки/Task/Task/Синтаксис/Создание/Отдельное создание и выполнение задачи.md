Класс *Task* также предоставляет конструкторы, которые инициализируют задачу, но не планируют ее выполнение. По соображениям производительности, метод `Task.Run` или метод `TaskFactory.StartNew` является предпочтительным механизмом для создания и планирования вычислительных задач, но для сценариев, когда создание и планирование должны быть разделены, можно использовать конструкторы, а затем вызвать метод `Task.Start` для последующего выполнения задачи

```C#
Task task = new Task(MyTask)

/* ... */

task.Start();
```

В отличии от `Task.Factory` и `Task.Run` не является атомарной операцией и лишён большей части их оптимизаций
Но обладает недостатком `Task.Factory`, в виде выбора Текущего планировщика потоков по умолчанию
То есть, если создавать Task таким образом из UI-потока, то метод будет выполняться в UI-потоке, если не указать *TaskScheduler.Default* в конструкторе