Отслеживание прогресса простого цикла

#### Контроллер
```C#
class Controller
{
	private int _number = 0;
	private IProgress<int> _reporter;
	
	// Конструктор
	public Controller(IProgress<int> reporter)
	{
		_reporter = reporter;
	}
	
	public void StartProgress()
	{
		while(true)
		{
			_reporter?.Report(_number++);
		}
	}
}
```
`StartProgress()` - Метод, который из фонового потока будет передавать в UI-поток информацию, не используя `return`

`IProgress<int>` - В контроллер передаётся интерфейс, а не конкретный объект класса ради Низкой связанности
Потому что гипотетически мы можем вместо объекта класса `Progress`, передать что-то что наследуется от интерфейса IProgress и написать свой класс, с логированием на пример

#### WinForms
```C#
public class CicleProgressForm : Form
{
	private readonly Controller _controller;
	
	public CicleProgressForm()
	{
		InitializeComponent();
		
		Progress<int> reporter = new Progress<int>(newNum => 
		{
			TextBox.Text = newNum.ToString();
		});
		_controller = new Controller(reporter);
		
		try
		{
			_ = StartCicleAsync();
		}
		catch (Exception ex) { /* ... */ }
	}
	
	private async Task StartCicleAsync()
	{
		await Task.Run(() => _controller.StartProgress());		
	}
}
```
`_controller` - Объект контроллера, который был описан до этого
`async void StartCicleAsync()` - Чаще всего, async методы должны возвращать Task, но если внутри этого метода мы обрабатываем все ошибки,  а результат его нам не нужен, то мы можем указать в сигнатуре void