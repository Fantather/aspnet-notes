Получение сообщения от сервера и отображения его в UI

Объяснение, мы имеем абстрактный класс, от которого наследуются все классы, которые будут содержать информацию для UI
И по присланному классу UI будет понимать, что именно нужно делать
А современный `Progress<T>` позволит нам сохранить разделение ответственности, ведь контроллер не будет знать, какие именно изменения он вызывает в UI, просто будет вызывать метод `Report` с информацией для UI

#### Класс-контейнер для обращений к UI
Абстрактный класс, от которого наследуются все обращения к UI
В нём можно хранить что-то общее для них всех, на пример - время
```C#
public abstract class NetworkUpdate
{
	/* ... */
}
```

```C#
public class ChatMessageUpdate : NetworkUpdate
{
	public string Message { get; }
	
	public ChatMessageUpdate(string message)
	{
		Message = message;
	}
}

public class UserListUpdate : NetworkUpdate
{
	public List<string> Users { get; }
	
	public UserListUpdate(List<string> users)
	{
		Users = users;
	}
}
```
`public object Data` - Data хранится в виде object, что бы сюда можно было поместить любой тип, а UpdateType говорит, какого типа данные хранятся в Data

Тут не используется `NetworkUpdate<T>`, потому что это будет класс обёртка для сообщений с сервера
И что бы использовать только один `IProgress` для передачи любых сообщений, а не несколько типизированных `IProgress`, на пример `IProgress<NetworkUpdate<int>>` и `IProgress<NetworkUpdate<string>>`, в итоге будут отличаться и им потребуются `IProgress<T>` для каждого типа

#### Упаковка на стороне сервера
```C#
public class NetworkServer()
{
	EndPoint ClientEndPoint { get; set; } 
	public async Task SendMessage(string message)
	{
		UdpClient client = new UdpClient(ClientEndPoint);
		
		byte[] serverMessage = Json.SerializeToUtf8(new ChatMessageUpdate(message));
		await client.SendAsync(serverMessage);
	}
}
```
`ClientIP` - в реальности сервер определит IP клиента при получении от него пакета или при установке TCP соединения, но не важно

#### Контроллер
```C#
public class NetworkController
{
	private readonly IProgress<NetworkUpdate> _reporter;
	
	public NetworkController(IProgress<NetworkUpdate?> reporter)
	{
		_reporter = reporter;
	}
	
	// Ожидаем данные с сервера
	public async Task StartListenServer()
	{
		UdpClient client = ner UdpClient("127.0.0.1", 54670);
		while
		{
			// Получили NetworkUpdate и десериализуем её
			UdpReceiveResult receiveResult = await client.ReceiveAsync();
			NetworkUpdate newUpdate = 
			JsonSerializer.Deserialize<NetworkUpdate>(receiveResult.Buffer);
			
			_reporter?.Report(newUpdate);
		}
	}
}
```
`StartListenServer()` - теперь контроллер может отправлять данные в UI-поток, не прерывая своего выполнения


#### WinForms
```C#
public class ChatForm() : Form
{
	public ChatForm()
	{
	    InitializeComponent();
		
	    // Мы создаем Progress для 'NetworkUpdate'
	    var reporter = new Progress<NetworkUpdate>(update =>
	    {
	        switch (update)
	        {
	            case ChatMessageUpdate chatMsg:
	                myChatTextBox.AppendText(chatMsg.Message);
	                break;
				
	            case UserListUpdate userList:
		            UpdateUserListBox(userList.Users);
		            break;
	            
	            // Обработка null и по умолчанию  
	            case null:
	            default:
		            break;
	        }
	    });
		
	    _controller = new NetworkController(reporter);
	    // ...
	}
}
```