У потоков есть ThreadQueue
Планировщик процессов распределяет процессорное время между потоками

[[Процесс|Процесс]] не будет закрыт и будет ожидать завершения всех основных потоков
Он может завершиться не дождавшись завершения фоновых потоков, они будут аварийно закрыты

Есть ThreadPool - очередь фоновых потоков, которые создаются и закрываются ОС

##### Рекомендации
Создание потока это тяжёлая операция
Потоки нужно открывать и закрывать
Поэтому их не нужно создавать всегда

##### Цели потоков
Нужны для приложений которые
- Имеют основное окно (GUI), главный поток занят отображением формы
  Поэтому любая функция запущенная в основном потоке будет тормозить GUI
  Что бы этого избежать, тяжёлые расчёты(числа Фибоначчи, рендеринг), такие как обращение к БД, обращение по сети к Серверу, запись в файл, тяжёлые расчёты, стоит выносить в отдельные потоки
- Нужны для одновременного исполнения кода


У потока есть статусы, хранятся в виде `enum`
- Закрыт
- Аварийно прерван и т.д.


##### Виды потоков
Foreground (основные) - Потоки, которые по своей сути являются основными

Background (фоновые) - фоновые потоки



##### Как заставить основной поток подождать фоновый
- Не дать закрыться Main или не закрываем Form пока все фоновые потоки не завершатся
- Метод Join


##### Способы закрытия потока
- **Interrupt**
  Это мягкий, «вежливый» способ попросить поток завершиться
  Потоку посылается сигнал прерывания
  Но поток завершится не сразу, а только если он находится в состоянии *ожидания*:
  - `Thread.Sleep`
  - `Thread.Join`
  - `WaitOne`
  - `Monitor.Wait` и т.п.
  
  В этот момент в потоке выбрасывается `ThreadInterruptedException`, который можно перехватить `try/catch`
  
  То есть поток сам решает, что делать дальше - он может корректно завершиться, либо обработать исключение и продолжить работу
  
- **Abort**
  В поток **насильно кидается исключение** `ThreadAbortException`
  
  Оно может выскочить **в любой точке выполнения кода**, даже посреди критической секции
  
  Код может попытаться выполнить `finally`, но поток всё равно будет завершён (если только явно не вызвать `Thread.ResetAbort`)
  
  Это грубый способ, из-за него легко словить:
  - «битое» состояние данных
  - нарушение целостности коллекций
  - утечки ресурсов
  
  Поэтому `Abort` признан **опасным и устаревшим** (его вообще убрали из .NET Core/5+).