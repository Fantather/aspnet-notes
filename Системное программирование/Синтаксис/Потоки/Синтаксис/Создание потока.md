**Ручное создание**
Мы вручную создаём объект потока, запускаем его и потом закрываем его
Поток создаётся для конкретного метода
```C#
Thread fon = new Thread(new ThreadStart(MethodName));
fon.IsBackground = false; // Основной поток
fon.Start();


Thread th = new Thread(new ThreadStart(MethodName));
th.IsBackground = true; // Фоновый поток
th.Start();
th.Join();
```
`Thread` - Объект потока
`ThreadStart` - 
`fon.IsBackground` - false по умолчанию, Свойство говорит этот поток основной или фоновый
`fon.Start();` - Запуск потока
`th.Join();` - обращение к главному потоку с просьбой подождать  завершения фонового потока, блокирующий метод



##### Использование системных потоков
Используем потоки созданные системой (ThreadPool)
ThreadPool - очередь фоновых потоков, которые создаются и закрываются ОС
```C#
void SomeMethod(int a);
Action<int>d;
d = SomeMethod;
IAsyncResult ar = d.BeginInvoke(6);

d.EndInvoke(ar);

// Условие станет false, когда поток завершится
// Программа не завершит работу, пока IsCompleted не станет true
// То есть пока фоновый поток не закроется
while(!ar.IsCompleted)
{
	Thread.Sleep(300);
}
```
`BeginInvoke` - Помещает методы из Делегата в Системный поток из *ThreadPool*
Создаёт фоновый поток по умолчанию, его можно превратить в основной, но не стоит этого делать
Возвращает объект типа `IAsyncResult`
Принимает параметры, которые требует делегат

`EndInvoke()`
- Блокирующий метод
  Программа не закроется, пока не будет закончен указанный фоновый поток
- Если завернуть его в try catch - позволит отловить Основному потоку отловить Исключение, которое возникло в ThreadPool, без этого исключение пропадёт
- Возвращает результат, если он есть, для этого можно присвоить этот метод переменной

Вызывается из Делегата, Принимает тип `IAsyncResult`, который принадлежит этому делегату


**Через класс ThreadPool**
Этот класс позволяет помещать в ThreadPool методы, которые возвращают `void` и принимают только `object`
```C#
ThreadPool.QueueUserWorkItem(JobForAThread, 100);
```