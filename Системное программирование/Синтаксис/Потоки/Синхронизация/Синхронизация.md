
Если операция в потоке не атомарная, то менеджер потоков может прервать её выполнение, она сохранит локально значение с которым работала и будет работать с этим локальным значением,  

Атомарная операция - означает что использовать атомарный блок кода не будут использовать другие потоки, пока текущий поток не завершит свою работу

**Кому нужна синхронизация**



### Примитивы синхронизации в C#

*Interlocked*
- Набор статических методов (`Increment`, `Decrement`, `Add`, `Exchange`, `CompareExchange`), которые выполняют простейшие операции над целыми числами и ссылками атомарно.
- Используются для обеспечения корректного доступа к общим переменным без явных блокировок.
- Очень быстрые, но подходят только для простых операций с одним значением (не для сложных критических секций).

`lock`
Гарантирует, что только один поток за раз выполняет код внутри блока
Пока один поток работает в заблокированном участке, остальные ожидают
- Синтаксический сахар для `Monitor.Enter` / `Monitor.Exit`

- Автоматически освобождает блокировку, даже если в коде возникло исключение (поэтому надёжнее `Monitor`)

- Используется чаще всего, так как простой и безопасный вариант для синхронизации

`Monitor`

- Класс, предоставляющий методы `Enter`, `Exit`, `TryEnter`, `Wait`, `Pulse`, `PulseAll`.

- Даёт более гибкий контроль над блокировками:

 - Можно попробовать войти с таймаутом (`TryEnter`)

 - Можно «усыпить» поток внутри критической секции (`Wait`)

 - Можно «разбудить» один или все ожидающие потоки (`Pulse`, `PulseAll`).

- Но: нужно вручную вызывать `Exit` → если забыть, будет дедлок.

- Обычно используется в случаях, когда требуется тонкая настройка взаимодействия потоков (например, продюсер-потребитель)