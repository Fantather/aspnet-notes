*TaskScheduler* - это абстрактный класс, который используется для того, что бы мы могли выбрать планировщик потоков, который хотим передать наш Task

#### TaskScheduler.Default
Планировщик по умолчанию, наследник *TaskScheduler*

Занимается управлением Пула Потоков (ThreadPool)
Группа потоков(Thread) созданная по запросу CLR (.NET), которая не закрывается после использования, а простаивает
Именно он решает, в какой конкретно поток в Пуле поток поместить переданный метод

Используется, потому что создание потока это очень тяжёлая операция и с точки зрения производительности эффективнее заранее создать несколько потоков, что бы потом помещать в них лёгкие задачи

Для тяжёлых задач, которые будут длиться часами стоит использовать `TaskCreationOptions.LongRunning` при создании `Task.Factory`
Этот флаг - подсказка для TPL, что эту задачу не следует помещать в Пул Потоков
Вместо этого TPL, скорее всего, создаст для этого Task отдельный поток, этот поток не будет частью ThreadPool и не будет мешать выполнению других, коротких задач

#### TaskScheduler.FromCurrentSynchronizationContext()
Планировщик Контекста Синхронизации, наследник *TaskScheduler*

В приложениях с графическим интерфейсом (WinForms, WPF, MAUI, старый UWP) существует специальный *контекст синхронизации* (Synchronization Context), привязанный к *единственному UI-потоку*

B Планировщик Контекста Синхронизации ставит задачи в очередь, которая выполняется *только на этом конкретном UI-потоке*

Это жизненно необходимо для безопасного обновления интерфейса (например, изменения текста в `TextBox` или добавления элемента в `ListBox`). Доступ к UI-элементам из любого другого потока (включая пул потоков) вызовет исключение

`async`/`await` использует его по умолчанию
Когда вы делаете `await` в методе, который был вызван из UI-потока, код _после_ `await` автоматически планируется обратно в этот UI-контекст

Если попытаться использовать флаг *LongRunning* при отправке задачи Планировщику Контекста Синхронизации, то он его проигнорирует, потому что работает с одним конкретным потоком


#### Пользовательские (Custom) планировщики
Мы можем написать свой собственный планировщик, унаследовав класс `TaskScheduler`. Это позволяет реализовать очень сложные сценарии, например:
- *Ограничение параллелизма*: Создать планировщик, который гарантирует, что не более N задач выполняются одновременно
- *Выделенные потоки*: Создать планировщик, который выполняет задачи на одном или нескольких специально созданных потоках (не из пула)
- *Порядок выполнения*: Создать планировщик, который выполняет задачи строго по порядку (FIFO) на одном потоке